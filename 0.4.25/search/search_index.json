{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin: tabular","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara.</p>"},{"location":"#description","title":"Description","text":"<p>kiara data-types and modules for working with tables and databases.</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#data_types","title":"data_types","text":"<ul> <li> <p><code>array</code>: An array, in most cases used as a column within a table.</p> </li> <li> <p><code>database</code>: A database, containing one or several tables.</p> </li> <li> <p><code>table</code>: Tabular data (table, spreadsheet, data_frame, what have you).</p> </li> </ul>"},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>table.filters</code>: -- n/a --</p> </li> <li> <p><code>render.database</code>: -- n/a --</p> </li> <li> <p><code>render.table</code>: -- n/a --</p> </li> <li> <p><code>export.table</code>: Export table data items.</p> </li> <li> <p><code>load.array</code>: Deserialize array data.</p> </li> <li> <p><code>load.database</code>: -- n/a --</p> </li> <li> <p><code>load.table</code>: -- n/a --</p> </li> <li> <p><code>parse.date_array</code>: Create an array of date objects from an array of strings.</p> </li> <li> <p><code>create.database</code>: -- n/a --</p> </li> <li> <p><code>create.table</code>: -- n/a --</p> </li> <li> <p><code>query.database</code>: Execute a sql query against a (sqlite) database.</p> </li> <li> <p><code>table.pick.column</code>: Pick one column from a table, returning an array.</p> </li> <li> <p><code>table.merge</code>: Create a table from other tables and/or arrays.</p> </li> <li> <p><code>query.table</code>: Execute a sql query against an (Arrow) table.</p> </li> </ul>"},{"location":"#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>database_metadata</code>: Database and table properties.</p> </li> <li> <p><code>kiara_table_metadata</code>: File stats.</p> </li> <li> <p><code>table_metadata</code>: Describes properties for the 'table' data type.</p> </li> <li> <p><code>kiara_array</code>: A class to manage array-like data.</p> </li> <li> <p><code>kiara_database</code>: A wrapper class to manage a sqlite database.</p> </li> <li> <p><code>kiara_table</code>: A wrapper class to manage tabular data in a memory efficient way.</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>create.database.from.file</code>: Create a database from a file.</p> </li> <li> <p><code>create.database.from.file_bundle</code>: Create a database from a file_bundle value.</p> </li> <li> <p><code>create.database.from.table</code>: Create a database value from a table.</p> </li> <li> <p><code>create.table.from.file</code>: Create a table from a file, trying to auto-determine the format of said file.</p> </li> <li> <p><code>create.table.from.file_bundle</code>: Create a table value from a text file_bundle.</p> </li> <li> <p><code>deserialize.array.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.database.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.table.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>export.table.as.csv_file</code>: Export a table as csv file.</p> </li> <li> <p><code>extract.date_array.from.table</code>: Extract a date array from a table column.</p> </li> <li> <p><code>import.database.from.local_file_path</code>: Import a database from a csv file.</p> </li> <li> <p><code>import.table.from.local_file_path</code>: Import a table from a file on the local filesystem.</p> </li> <li> <p><code>import.table.from.local_folder_path</code>: Import a table from a local folder containing text files.</p> </li> <li> <p><code>parse.date_array</code>: Create an array of date objects from an array of strings.</p> </li> <li> <p><code>query.database</code>: Execute a sql query against a (sqlite) database.</p> </li> <li> <p><code>query.table</code>: Execute a sql query against an (Arrow) table.</p> </li> <li> <p><code>render.database.as.string</code>: -- n/a --</p> </li> <li> <p><code>render.database.as.terminal_renderable</code>: -- n/a --</p> </li> <li> <p><code>render.table.as.string</code>: -- n/a --</p> </li> <li> <p><code>render.table.as.terminal_renderable</code>: -- n/a --</p> </li> <li> <p><code>table.pick.column</code>: Pick one column from a table, returning an array.</p> </li> <li> <p><code>table_filter.drop_columns</code>: -- n/a --</p> </li> <li> <p><code>table_filter.select_columns</code>: -- n/a --</p> </li> <li> <p><code>table_filter.select_rows</code>: -- n/a --</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.tabular</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.tabular</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Usage</li> <li>Development</li> <li>Package contents</li> <li>API reference</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>data_types</li> <li>module_types</li> <li>kiara_model_types</li> <li>operations</li> </ul>"},{"location":"info/data_types/","title":"data_types","text":""},{"location":"info/data_types/#kiara_info.data_types.array","title":"<code>array</code>","text":"<pre>                                                                                \n lineage              array                                                     \n                      any                                                       \n qualifier profile(s) -- n/a --                                                 \n Documentation                                                                  \n    An array, in most cases used as a column within a       \n                        table.                                                  \n                        Internally, this type uses the                          \n                        [KiaraArray][kiara_plugin.tabular.models.array.Kiara\u2026   \n                        wrapper class to manage array data. This wrapper        \n                        class, in turn, uses an Apache Arrow Array to store     \n                        the data in memory (and on disk).                       \n                     Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                      \n Context                                                                        \n  Tags         tabular                                    \n                      Labels       package: kiara_plugin.tabular              \n                      References   source_repo:                               \n                     https://github.com/DHARPA-Project/kiara\u2026   \n documentation:                             \n                     https://DHARPA-Project.github.io/kiara_\u2026   \n Python class                                                                   \n  python_class_name    ArrayType                          \n                      python_module_name   kiara_plugin.tabular.data_types\u2026   \n                      full_name            kiara_plugin.tabular.data_types\u2026   \n                     Config class                                                                   \n  python_class_name    DataTypeConfig                     \n                      python_module_name   kiara.data_types                   \n                      full_name            kiara.data_types.DataTypeConfig    \n                     Value class                                                                    \n  python_class_name    KiaraArray                         \n                      python_module_name   kiara_plugin.tabular.models.arr\u2026   \n                      full_name            kiara_plugin.tabular.models.arr\u2026   \n                     </pre>"},{"location":"info/data_types/#kiara_info.data_types.database","title":"<code>database</code>","text":"<pre>                                                                                \n lineage              database                                                  \n                      any                                                       \n qualifier profile(s) -- n/a --                                                 \n Documentation                                                                  \n    A database, containing one or several tables.           \n                        This is backed by the                                   \n                        [KiaraDatabase][kiara_plugin.tabular.models.db.Kiara\u2026   \n                        class to manage the stored data.                        \n                     Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                      \n Context                                                                        \n  Tags         tabular                                    \n                      Labels       package: kiara_plugin.tabular              \n                      References   source_repo:                               \n                     https://github.com/DHARPA-Project/kiara\u2026   \n documentation:                             \n                     https://DHARPA-Project.github.io/kiara_\u2026   \n Python class                                                                   \n  python_class_name    DatabaseType                       \n                      python_module_name   kiara_plugin.tabular.data_types\u2026   \n                      full_name            kiara_plugin.tabular.data_types\u2026   \n                     Config class                                                                   \n  python_class_name    DataTypeConfig                     \n                      python_module_name   kiara.data_types                   \n                      full_name            kiara.data_types.DataTypeConfig    \n                     Value class                                                                    \n  python_class_name    KiaraDatabase                      \n                      python_module_name   kiara_plugin.tabular.models.db     \n                      full_name            kiara_plugin.tabular.models.db.\u2026   \n                     </pre>"},{"location":"info/data_types/#kiara_info.data_types.table","title":"<code>table</code>","text":"<pre>                                                                                \n lineage              table                                                     \n                      any                                                       \n qualifier profile(s) -- n/a --                                                 \n Documentation                                                                  \n    Tabular data (table, spreadsheet, data_frame, what      \n                        have you).                                              \n                        The table data is organized in sets of columns          \n                        (arrays of data of the same type), with each column     \n                        having a string identifier.                             \n                     kiara uses an instance of the                           \n                        [KiaraTable][kiara_plugin.tabular.models.table.Kiara\u2026   \n                        class to manage the table data, which let's             \n                        developers access it in different formats (Apache       \n Arrow Table, Pandas dataframe, Python dict of lists,    \n                        more to follow...).                                     \n                        Please consult the API doc of the KiaraTable class      \n                        for more information about how to access and query      \n                        the data:                                               \n                      \u2022 KiaraTable API doc                                   \n    Internally, the data is stored in Apache Feather        \n format -- both in memory and on disk when saved,        \n                        which enables some advanced usage to preserve memory    \n                        and compute overhead.                                   \n                     Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                      \n Context                                                                        \n  Tags         tabular                                    \n                      Labels       package: kiara_plugin.tabular              \n                      References   source_repo:                               \n                     https://github.com/DHARPA-Project/kiara\u2026   \n documentation:                             \n                     https://DHARPA-Project.github.io/kiara_\u2026   \n Python class                                                                   \n  python_class_name    TableType                          \n                      python_module_name   kiara_plugin.tabular.data_types\u2026   \n                      full_name            kiara_plugin.tabular.data_types\u2026   \n                     Config class                                                                   \n  python_class_name    DataTypeConfig                     \n                      python_module_name   kiara.data_types                   \n                      full_name            kiara.data_types.DataTypeConfig    \n                     Value class                                                                    \n  python_class_name    KiaraTable                         \n                      python_module_name   kiara_plugin.tabular.models.tab\u2026   \n                      full_name            kiara_plugin.tabular.models.tab\u2026   \n                     </pre>"},{"location":"info/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.database_metadata","title":"<code>database_metadata</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Database and table properties.                                 \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    DatabaseMetadata                          \n               python_module_name   kiara_plugin.tabular.models.db            \n               full_name            kiara_plugin.tabular.models.db.Databas\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.kiara_table_metadata","title":"<code>kiara_table_metadata</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    File stats.                                                    \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    KiaraTableMetadata                        \n               python_module_name   kiara_plugin.tabular.models.table         \n               full_name            kiara_plugin.tabular.models.table.Kiar\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.table_metadata","title":"<code>table_metadata</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Describes properties for the 'table' data type.                \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    TableMetadata                             \n               python_module_name   kiara_plugin.tabular.models               \n               full_name            kiara_plugin.tabular.models.TableMetad\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.kiara_array","title":"<code>kiara_array</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A class to manage array-like data.                             \n                 Internally, this uses an Apache Arrow Array to handle the      \n                 data in memory and on disk.                                    \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    KiaraArray                                \n               python_module_name   kiara_plugin.tabular.models.array         \n               full_name            kiara_plugin.tabular.models.array.Kiar\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.kiara_database","title":"<code>kiara_database</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A wrapper class to manage a sqlite database.                   \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    KiaraDatabase                             \n               python_module_name   kiara_plugin.tabular.models.db            \n               full_name            kiara_plugin.tabular.models.db.KiaraDa\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.kiara_table","title":"<code>kiara_table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A wrapper class to manage tabular data in a memory efficient   \n                 way.                                                           \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         tabular                                           \n               Labels       package: kiara_plugin.tabular                     \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    KiaraTable                                \n               python_module_name   kiara_plugin.tabular.models.table         \n               full_name            kiara_plugin.tabular.models.table.Kiar\u2026   \n              </pre>"},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.table.filters","title":"<code>table.filters</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          filter_n\u2026   string   The name    yes                  \n                                               of the                           \n                                               filter.                          \n                       Python class                                                                   \n  python_class_name    TableFiltersModule               \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class TableFiltersModule(FilterModule):               \n     _module_type_name = \"table.filters\"               \n @classmethod                                      \n def retrieve_supported_type(cls) -&gt; Union[Dict\u2026   \n return \"table\"                                \n def create_filter_inputs(self, filter_name: st\u2026   \n if filter_name in [\"select_columns\", \"drop\u2026   \n return {                                  \n \"columns\": {                          \n \"type\": \"list\",                   \n \"doc\": \"The name of the column\u2026   \n \"optional\": True,                 \n                 },                                    \n \"ignore_invalid_column_names\": {      \n \"type\": \"boolean\",                \n \"doc\": \"Whether to ignore inva\u2026   \n \"default\": True,                  \n                 },                                    \n             }                                         \n elif filter_name == \"select_rows\":            \n return {                                  \n \"match\": {                            \n \"type\": \"string\",                 \n \"doc\": \"The string token to ma\u2026   \n \"optional\": True,                 \n                 },                                    \n \"case_insensitive\": {                 \n \"type\": \"boolean\",                \n \"doc\": \"Whether to ignore case\u2026   \n \"default\": True,                  \n                 },                                    \n             }                                         \n return None                                   \n def filter__select_columns(self, value: Value,\u2026   \n import pyarrow as pa                          \n         ignore_invalid = filter_inputs[\"ignore_inv\u2026   \n         column_names = filter_inputs[\"columns\"]       \n if not column_names:                          \n return value                              \n         table: KiaraTable = value.data                \n         arrow_table = table.arrow_table               \n         _column_names = []                            \n         _columns = []                                 \n for column_name in column_names:              \n if column_name not in arrow_table.colu\u2026   \n if ignore_invalid:                    \n continue                          \n else:                                 \n raise KiaraProcessingException(   \n f\"Can't select column '{co\u2026   \n                     )                                 \n             column = arrow_table.column(column_nam\u2026   \n             _column_names.append(column_name)         \n             _columns.append(column)                   \n return pa.table(data=_columns, names=_colu\u2026   \n def filter__drop_columns(self, value: Value, f\u2026   \n import pyarrow as pa                          \n         ignore_invalid = filter_inputs[\"ignore_inv\u2026   \n         column_names_to_ignore = filter_inputs[\"co\u2026   \n if not column_names_to_ignore:                \n return value                              \n         table: KiaraTable = value.data                \n         arrow_table = table.arrow_table               \n for column_name in column_names_to_ignore:    \n if column_name not in arrow_table.colu\u2026   \n if ignore_invalid:                    \n continue                          \n else:                                 \n raise KiaraProcessingException(   \n f\"Can't select column '{co\u2026   \n                     )                                 \n         _column_names = []                            \n         _columns = []                                 \n for column_name in arrow_table.column_name\u2026   \n if column_name in column_names_to_igno\u2026   \n continue                              \n             column = arrow_table.column(column_nam\u2026   \n             _column_names.append(column_name)         \n             _columns.append(column)                   \n return pa.table(data=_columns, names=_colu\u2026   \n def filter__select_rows(self, value: Value, fi\u2026   \n         match = filter_inputs.get(\"match\", None)      \n if not match:                                 \n return value                              \n         case_insensitive = filter_inputs.get(\"case\u2026   \n import duckdb                                 \n         _table: KiaraTable = value.data               \n         rel_from_arrow = duckdb.arrow(_table.arrow\u2026   \n if case_insensitive:                          \n # query_tokens = [f\"LOWER({c}) GLOB LO\u2026   \n             query_tokens = [                          \n f\"regexp_matches(LOWER({c}), LOWER\u2026   \n for c in rel_from_arrow.columns       \n             ]                                         \n else:                                         \n             query_tokens = [                          \n f\"regexp_matches({c}, '{match}')\" \u2026   \n             ]                                         \n         query = \" OR \".join(query_tokens)             \n         result = rel_from_arrow.filter(query)         \n return result.arrow()                         \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.render.database","title":"<code>render.database</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               to be                            \n                                               rendered.                        \n                          target_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               of210 the                        \n                                               rendered                         \n                                               result.                          \n                       Python class                                                                   \n  python_class_name    RenderDatabaseModule             \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class RenderDatabaseModule(RenderDatabaseModuleBas\u2026   \n     _module_type_name = \"render.database\"             \n def render__database__as__string(                 \n         self, value: Value, render_config: Mapping\u2026   \n     ):                                                \n         input_number_of_rows = render_config.get(\"\u2026   \n         input_row_offset = render_config.get(\"row_\u2026   \n         table_name = render_config.get(\"table_name\u2026   \n         wrap, data_related_scenes = self.preproces\u2026   \n             value=value,                              \n             table_name=table_name,                    \n             input_number_of_rows=input_number_of_r\u2026   \n             input_row_offset=input_row_offset,        \n         )                                             \n         pretty = wrap.as_string(max_row_height=1)     \n return RenderValueResult(                     \n             value_id=value.value_id,                  \n             rendered=pretty,                          \n             related_scenes=data_related_scenes,       \n             render_config=render_config,              \n             render_manifest=self.manifest.manifest\u2026   \n         )                                             \n def render__database__as__terminal_renderable(    \n         self, value: Value, render_config: Mapping\u2026   \n     ):                                                \n         input_number_of_rows = render_config.get(\"\u2026   \n         input_row_offset = render_config.get(\"row_\u2026   \n         table_name = render_config.get(\"table_name\u2026   \n         wrap, data_related_scenes = self.preproces\u2026   \n             value=value,                              \n             table_name=table_name,                    \n             input_number_of_rows=input_number_of_r\u2026   \n             input_row_offset=input_row_offset,        \n         )                                             \n         pretty = wrap.as_terminal_renderable(max_r\u2026   \n return RenderValueResult(                     \n             value_id=value.value_id,                  \n             render_config=render_config,              \n             rendered=pretty,                          \n             related_scenes=data_related_scenes,       \n             render_manifest=self.manifest.manifest\u2026   \n         )                                             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.render.table","title":"<code>render.table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               to be                            \n                                               rendered.                        \n                          target_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               of210 the                        \n                                               rendered                         \n                                               result.                          \n                       Python class                                                                   \n  python_class_name    RenderTableModule                \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class RenderTableModule(RenderTableModuleBase):       \n     _module_type_name = \"render.table\"                \n def render__table__as__string(self, value: Val\u2026   \n         input_number_of_rows = render_config.get(\"\u2026   \n         input_row_offset = render_config.get(\"row_\u2026   \n         wrap, data_related_scenes = self.preproces\u2026   \n             value=value,                              \n             input_number_of_rows=input_number_of_r\u2026   \n             input_row_offset=input_row_offset,        \n         )                                             \n         pretty = wrap.as_string(max_row_height=1)     \n return RenderValueResult(                     \n             value_id=value.value_id,                  \n             render_config=render_config,              \n             render_manifest=self.manifest.manifest\u2026   \n             rendered=pretty,                          \n             related_scenes=data_related_scenes,       \n         )                                             \n def render__table__as__terminal_renderable(       \n         self, value: Value, render_config: Mapping\u2026   \n     ):                                                \n         input_number_of_rows = render_config.get(\"\u2026   \n         input_row_offset = render_config.get(\"row_\u2026   \n         wrap, data_related_scenes = self.preproces\u2026   \n             value=value,                              \n             input_number_of_rows=input_number_of_r\u2026   \n             input_row_offset=input_row_offset,        \n         )                                             \n         pretty = wrap.as_terminal_renderable(max_r\u2026   \n return RenderValueResult(                     \n             value_id=value.value_id,                  \n             render_config=render_config,              \n             render_manifest=self.manifest.manifest\u2026   \n             rendered=pretty,                          \n             related_scenes=data_related_scenes,       \n         )                                             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.export.table","title":"<code>export.table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Export table data items.                              \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The type    yes                  \n                                               of the                           \n                                               source                           \n                                               data that                        \n                                               is going                         \n                                               to be                            \n                                               exported.                        \n                          target_p\u2026   string   The name    yes                  \n                                               of the                           \n                                               target                           \n                                               profile.                         \n                                               Used to                          \n                                               distingu\u2026                        \n                                               different                        \n                                               target                           \n                                               formats                          \n                                               for the                          \n                                               same data                        \n                                               type.                            \n                       Python class                                                                   \n  python_class_name    ExportTableModule                \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ExportTableModule(DataExportModule):            \n \"\"\"Export table data items.\"\"\"                    \n     _module_type_name = \"export.table\"                \n def export__table__as__csv_file(self, value: K\u2026   \n \"\"\"Export a table as csv file.\"\"\"             \n from pyarrow import csv                       \n         target_path = os.path.join(base_path, f\"{n\u2026   \n         csv.write_csv(value.arrow_table, target_pa\u2026   \n return {\"files\": target_path}                 \n # def export__table__as__sqlite_db(               \n #     self, value: KiaraTable, base_path: str,\u2026   \n # ):                                              \n #                                                 \n #     target_path = os.path.abspath(os.path.jo\u2026   \n #                                                 \n #     raise NotImplementedError()                 \n #     # shutil.copy2(value.db_file_path, targe\u2026   \n #                                                 \n #     return {\"files\": target_path}               \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.load.array","title":"<code>load.array</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Deserialize array data.                               \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          serializ\u2026   string   The name    yes                  \n                                               of the                           \n                                               serializ\u2026                        \n                                               profile                          \n                                               used to                          \n                                               serialize                        \n                                               the                              \n                                               source                           \n                                               value.                           \n                          target_p\u2026   string   The         yes                  \n                                               profile                          \n                                               name of                          \n                                               the                              \n                                               de-seria\u2026                        \n                                               result                           \n                                               data.                            \n                          value_ty\u2026   string   The value   yes                  \n                                               type of                          \n                                               the                              \n                                               actual                           \n                                               (unseria\u2026                        \n                                               value.                           \n                       Python class                                                                   \n  python_class_name    DeserializeArrayModule           \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class DeserializeArrayModule(DeserializeValueModul\u2026   \n \"\"\"Deserialize array data.\"\"\"                     \n     _module_type_name = \"load.array\"                  \n @classmethod                                      \n def retrieve_supported_target_profiles(cls) -&gt;\u2026   \n return {\"python_object\": KiaraArray}          \n @classmethod                                      \n def retrieve_serialized_value_type(cls) -&gt; str:   \n return \"array\"                                \n @classmethod                                      \n def retrieve_supported_serialization_profile(c\u2026   \n return \"feather\"                              \n def to__python_object(self, data: SerializedDa\u2026   \n assert \"array.arrow\" in data.get_keys() an\u2026   \n         chunks = data.get_serialized_data(\"array.a\u2026   \n # TODO: support multiple chunks               \n assert chunks.get_number_of_chunks() == 1     \n         files = list(chunks.get_chunks(as_files=Tr\u2026   \n assert len(files) == 1                        \n         array_file = files[0]                         \n         array = KiaraArray(data_path=array_file)      \n return array                                  \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.load.database","title":"<code>load.database</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          serializ\u2026   string   The name    yes                  \n                                               of the                           \n                                               serializ\u2026                        \n                                               profile                          \n                                               used to                          \n                                               serialize                        \n                                               the                              \n                                               source                           \n                                               value.                           \n                          target_p\u2026   string   The         yes                  \n                                               profile                          \n                                               name of                          \n                                               the                              \n                                               de-seria\u2026                        \n                                               result                           \n                                               data.                            \n                          value_ty\u2026   string   The value   yes                  \n                                               type of                          \n                                               the                              \n                                               actual                           \n                                               (unseria\u2026                        \n                                               value.                           \n                       Python class                                                                   \n  python_class_name    LoadDatabaseFromDiskModule       \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class LoadDatabaseFromDiskModule(DeserializeValueM\u2026   \n     _module_type_name = \"load.database\"               \n @classmethod                                      \n def retrieve_supported_target_profiles(cls) -&gt;\u2026   \n return {\"python_object\": KiaraDatabase}       \n @classmethod                                      \n def retrieve_serialized_value_type(cls) -&gt; str:   \n return \"database\"                             \n @classmethod                                      \n def retrieve_supported_serialization_profile(c\u2026   \n return \"copy\"                                 \n def to__python_object(self, data: SerializedDa\u2026   \n assert \"db.sqlite\" in data.get_keys() and \u2026   \n         chunks = data.get_serialized_data(\"db.sqli\u2026   \n # TODO: support multiple chunks               \n assert chunks.get_number_of_chunks() == 1     \n         files = list(chunks.get_chunks(as_files=Tr\u2026   \n assert len(files) == 1                        \n         db_file = files[0]                            \n         db = KiaraDatabase(db_file_path=db_file)      \n return db                                     \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.load.table","title":"<code>load.table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          serializ\u2026   string   The name    yes                  \n                                               of the                           \n                                               serializ\u2026                        \n                                               profile                          \n                                               used to                          \n                                               serialize                        \n                                               the                              \n                                               source                           \n                                               value.                           \n                          target_p\u2026   string   The         yes                  \n                                               profile                          \n                                               name of                          \n                                               the                              \n                                               de-seria\u2026                        \n                                               result                           \n                                               data.                            \n                          value_ty\u2026   string   The value   yes                  \n                                               type of                          \n                                               the                              \n                                               actual                           \n                                               (unseria\u2026                        \n                                               value.                           \n                       Python class                                                                   \n  python_class_name    DeserializeTableModule           \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class DeserializeTableModule(DeserializeValueModul\u2026   \n     _module_type_name = \"load.table\"                  \n @classmethod                                      \n def retrieve_supported_target_profiles(cls) -&gt;\u2026   \n return {\"python_object\": KiaraTable}          \n @classmethod                                      \n def retrieve_serialized_value_type(cls) -&gt; str:   \n return \"table\"                                \n @classmethod                                      \n def retrieve_supported_serialization_profile(c\u2026   \n return \"feather\"                              \n def to__python_object(self, data: SerializedDa\u2026   \n import pyarrow as pa                          \n         columns = {}                                  \n for column_name in data.get_keys():           \n             chunks = data.get_serialized_data(colu\u2026   \n # TODO: support multiple chunks           \n assert chunks.get_number_of_chunks() =\u2026   \n             files = list(chunks.get_chunks(as_file\u2026   \n assert len(files) == 1                    \n             file = files[0]                           \n with pa.memory_map(file, \"r\") as colum\u2026   \n                 loaded_arrays: pa.Table = pa.ipc.o\u2026   \n                 column = loaded_arrays.column(colu\u2026   \n if column_name == EMPTY_COLUMN_NAM\u2026   \n                     columns[\"\"] = column              \n else:                                 \n                     columns[column_name] = column     \n         arrow_table = pa.table(columns)               \n         table = KiaraTable.create_table(arrow_tabl\u2026   \n return table                                  \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.parse.date_array","title":"<code>parse.date_array</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create an array of date objects from an array of      \n                          strings.                                              \n                          This module is very simplistic at the moment, more    \n                          functionality and options will be added in the        \n                          future.                                               \n                          At its core, this module uses the standard parser     \n                          from the dateutil package to parse strings into       \n                          dates. As this parser can't handle complex strings,   \n                          the input strings can be pre-processed in the         \n                          following ways:                                       \n                        \u2022 'cut' non-relevant parts of the string (using      \n                       'min_index' &amp; 'max_index' input/config options)    \n                        \u2022 remove matching tokens from the string, and        \n                       replace them with a single whitespace (using the   \n                       'remove_tokens' option)                            \n                          By default, if an input string can't be parsed this   \n                          module will raise an exception. This can be           \n                          prevented by setting this modules 'force_non_null'    \n                          config option or input to 'False', in which case      \n                          un-parsable strings will appear as 'NULL' value in    \n                          the resulting array.                                  \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field      Type      Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          add_inp\u2026   boolean   If set to   no         true      \n                                               'True',                          \n                                               parse                            \n                                               options                          \n                                               will be                          \n                                               available                        \n                                               as                               \n                                               inputs.                          \n                          constan\u2026   object    Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults   object    Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          force_n\u2026   boolean   If set to   no         true      \n                                               'True',                          \n                                               raise an                         \n                                               error if                         \n                                               any of                           \n                                               the                              \n                                               strings                          \n                                               in the                           \n                                               array                            \n                                               can't be                         \n                                               parsed.                          \n                          input_f\u2026   array     If not      no                   \n                                               empty,                           \n                                               only add                         \n                                               the                              \n                                               fields                           \n                                               specified                        \n                                               in here                          \n                                               to the                           \n                                               module                           \n                                               inputs                           \n                                               schema.                          \n                          max_ind\u2026   integer   The         no                   \n                                               maximum                          \n                                               index                            \n                                               until                            \n                                               whic to                          \n                                               parse the                        \n                                               string(s\u2026                        \n                          min_ind\u2026   integer   The         no                   \n                                               minimum                          \n                                               index                            \n                                               from                             \n                                               where to                         \n                                               start                            \n                                               parsing                          \n                                               the                              \n                                               string(s\u2026                        \n                          remove_\u2026   array     A list of   no                   \n                                               tokens/c\u2026                        \n                                               to                               \n                                               replace                          \n                                               with a                           \n                                               single                           \n                                               white-sp\u2026                        \n                                               before                           \n                                               parsing                          \n                                               the                              \n                                               input.                           \n                       Python class                                                                   \n  python_class_name    ExtractDateModule                \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ExtractDateModule(AutoInputsKiaraModule):       \n \"\"\"Create an array of date objects from an arr\u2026   \n     This module is very simplistic at the moment, \u2026   \n     At its core, this module uses the standard par\u2026   \n     [dateutil](https://github.com/dateutil/dateuti\u2026   \n      complex strings, the input strings can be pre\u2026   \n     - 'cut' non-relevant parts of the string (usin\u2026   \n     - remove matching tokens from the string, and \u2026   \n     By default, if an input string can't be parsed\u2026   \n     setting this modules 'force_non_null' config o\u2026   \n     will appear as 'NULL' value in the resulting a\u2026   \n     \"\"\"                                               \n     _module_type_name = \"parse.date_array\"            \n     _config_cls = ExtractDateConfig                   \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         inputs = {\"array\": {\"type\": \"array\", \"doc\"\u2026   \n return inputs                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n return {                                      \n \"date_array\": {                           \n \"type\": \"array\",                      \n \"doc\": \"The resulting array with i\u2026   \n             }                                         \n         }                                             \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import polars as pl                           \n import pyarrow as pa                          \n from dateutil import parser                   \n         force_non_null: bool = self.get_data_for_f\u2026   \n             field_name=\"force_non_null\", inputs=in\u2026   \n         )                                             \n         min_pos: Union[None, int] = self.get_data_\u2026   \n             field_name=\"min_index\", inputs=inputs     \n         )                                             \n if min_pos is None:                           \n             min_pos = 0                               \n         max_pos: Union[None, int] = self.get_data_\u2026   \n             field_name=\"max_index\", inputs=inputs     \n         )                                             \n         remove_tokens: Iterable[str] = self.get_da\u2026   \n             field_name=\"remove_tokens\", inputs=inp\u2026   \n         )                                             \n def parse_date(_text: str):                   \n             text = _text                              \n if min_pos:                               \n try:                                  \n                     text = text[min_pos:]  # type:\u2026   \n except Exception:                     \n return None                       \n if max_pos:                               \n try:                                  \n                     text = text[0 : max_pos - min_\u2026   \n except Exception:                     \n pass                              \n if remove_tokens:                         \n for t in remove_tokens:               \n                     text = text.replace(t, \" \")       \n try:                                      \n                 d_obj = parser.parse(text, fuzzy=T\u2026   \n except Exception as e:                    \n if force_non_null:                    \n raise KiaraProcessingException\u2026   \n return None                           \n if d_obj is None:                         \n if force_non_null:                    \n raise KiaraProcessingException(   \n f\"Can't parse date from st\u2026   \n                     )                                 \n return None                           \n return d_obj                              \n         value = inputs.get_value_obj(\"array\")         \n         array: KiaraArray = value.data                \n         series = pl.Series(name=\"tokens\", values=a\u2026   \n         job_log.add_log(f\"start parsing date for {\u2026   \n         result = series.apply(parse_date)             \n         job_log.add_log(f\"finished parsing date fo\u2026   \n         result_array = result.to_arrow()              \n # TODO: remove this cast once the array da\u2026   \n         chunked = pa.chunked_array(result_array)      \n         outputs.set_values(date_array=chunked)        \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.database","title":"<code>create.database</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type      Descrip\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object    Value      no                   \n                                                constan\u2026                        \n                                                for this                        \n                                                module.                         \n                          defaults    object    Value      no                   \n                                                defaults                        \n                                                for this                        \n                                                module.                         \n                          ignore_e\u2026   boolean   Whether    no         false     \n                                                to                              \n                                                ignore                          \n                                                convert                         \n                                                errors                          \n                                                and omit                        \n                                                the                             \n                                                failed                          \n                                                items.                          \n                          include_\u2026   boolean   When       no         false     \n                                                includi\u2026                        \n                                                source                          \n                                                metadat\u2026                        \n                                                whether                         \n                                                to also                         \n                                                include                         \n                                                the                             \n                                                original                        \n                                                raw                             \n                                                (string)                        \n                                                content.                        \n                          include_\u2026   boolean   Whether    no                   \n                                                to                              \n                                                include                         \n                                                a table                         \n                                                with                            \n                                                metadata                        \n                                                about                           \n                                                the                             \n                                                source                          \n                                                files.                          \n                          merge_in\u2026   boolean   Whether    no         false     \n                                                to merge                        \n                                                all csv                         \n                                                files                           \n                                                into a                          \n                                                single                          \n                                                table.                          \n                          source_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                source                          \n                                                value.                          \n                          target_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                target.                         \n                       Python class                                                                   \n  python_class_name    CreateDatabaseModule             \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class CreateDatabaseModule(CreateFromModule):         \n     _module_type_name = \"create.database\"             \n     _config_cls = CreateDatabaseModuleConfig          \n def create__database__from__file(                 \n         self, source_value: Value, optional: Value\u2026   \n     ) -&gt; Any:                                         \n \"\"\"Create a database from a file.             \n         Currently, only csv files are supported.      \n         \"\"\"                                           \n import csv as py_csv                          \n         temp_f = tempfile.mkdtemp()                   \n         db_path = os.path.join(temp_f, \"db.sqlite\")   \n def cleanup():                                \n             shutil.rmtree(db_path, ignore_errors=T\u2026   \n         atexit.register(cleanup)                      \n         file_item: FileModel = source_value.data      \n if not file_item.file_name.endswith(\".csv\"\u2026   \n raise KiaraProcessingException(           \n \"Only csv files are supported (at \u2026   \n             )                                         \n         table_name = file_item.file_name_without_e\u2026   \n         table_name = table_name.replace(\"-\", \"_\")     \n         table_name = table_name.replace(\".\", \"_\")     \n         has_header = optional.get_value_data(\"firs\u2026   \n if has_header is None:                        \n try:                                      \n                 has_header = True                     \n with open(source_value.data.path, \u2026   \n                     sniffer = py_csv.Sniffer()        \n                     has_header = sniffer.has_heade\u2026   \n                     csvfile.seek(0)                   \n except Exception as e:                    \n # TODO: add this to the procss log    \n                 log_message(                          \n \"csv_sniffer.error\",              \n                     file=source_value.data.path,      \n                     error=str(e),                     \n                     details=\"assuming csv file has\u2026   \n                 )                                     \n try:                                          \n             create_sqlite_table_from_tabular_file(    \n                 target_db_file=db_path,               \n                 file_item=file_item,                  \n                 table_name=table_name,                \n                 no_headers=not has_header,            \n             )                                         \n except Exception as e:                        \n if self.get_config_value(\"ignore_error\u2026   \n                 log_message(\"ignore.import_file\", \u2026   \n else:                                     \n raise KiaraProcessingException(e)     \n         include_raw_content_in_file_info: bool = s\u2026   \n \"include_source_metadata\"                 \n         )                                             \n if include_raw_content_in_file_info:          \n             db = KiaraDatabase(db_file_path=db_pat\u2026   \n             db.create_if_not_exists()                 \n             include_content: bool = self.get_confi\u2026   \n             db._unlock_db()                           \n             included_files = {file_item.file_name:\u2026   \n             file_bundle = FileBundle.create_from_f\u2026   \n                 files=included_files, bundle_name=\u2026   \n             )                                         \n             insert_db_table_from_file_bundle(         \n                 database=db,                          \n                 file_bundle=file_bundle,              \n                 table_name=\"source_files_metadata\",   \n                 include_content=include_content,      \n             )                                         \n             db._lock_db()                             \n return db_path                                \n def create__database__from__file_bundle(          \n         self, source_value: Value, job_log: JobLog    \n     ) -&gt; Any:                                         \n \"\"\"Create a database from a file_bundle va\u2026   \n         Currently, only csv files are supported, f\u2026   \n         Unless 'merge_into_single_table' is set to\u2026   \n         in the resulting database. If this option \u2026   \n         csv files will be created. For this to wor\u2026   \n         \"\"\"                                           \n         merge_into_single_table = self.get_config_\u2026   \n if merge_into_single_table:                   \n raise NotImplementedError(\"Not support\u2026   \n         include_raw_content_in_file_info: Union[bo\u2026   \n \"include_source_metadata\"                 \n         )                                             \n         temp_f = tempfile.mkdtemp()                   \n         db_path = os.path.join(temp_f, \"db.sqlite\")   \n def cleanup():                                \n             shutil.rmtree(db_path, ignore_errors=T\u2026   \n         atexit.register(cleanup)                      \n         db = KiaraDatabase(db_file_path=db_path)      \n         db.create_if_not_exists()                     \n # TODO: check whether/how to add indexes      \n         bundle: FileBundle = source_value.data        \n         table_names: List[str] = []                   \n         included_files: Dict[str, bool] = {}          \n         errors: Dict[str, Union[None, str]] = {}      \n for rel_path in sorted(bundle.included_fil\u2026   \n if not rel_path.endswith(\".csv\"):         \n                 job_log.add_log(                      \n f\"Ignoring file (not csv): {re\u2026   \n                 )                                     \n                 included_files[rel_path] = False      \n                 errors[rel_path] = \"Not a csv file\u2026   \n continue                              \n             file_item = bundle.included_files[rel_\u2026   \n             table_name = find_free_id(                \n                 stem=file_item.file_name_without_e\u2026   \n             )                                         \n try:                                      \n                 table_names.append(table_name)        \n                 create_sqlite_table_from_tabular_f\u2026   \n                     target_db_file=db_path, file_i\u2026   \n                 )                                     \n                 included_files[rel_path] = True       \n except Exception as e:                    \n                 included_files[rel_path] = False      \n                 errors[rel_path] = KiaraException.\u2026   \n if self.get_config_value(\"ignore_e\u2026   \n                     log_message(\"ignore.import_fil\u2026   \n continue                          \n raise KiaraProcessingException(e)     \n if include_raw_content_in_file_info in [No\u2026   \n             include_content: bool = self.get_confi\u2026   \n             db._unlock_db()                           \n             insert_db_table_from_file_bundle(         \n                 database=db,                          \n                 file_bundle=source_value.data,        \n                 table_name=\"source_files_metadata\",   \n                 include_content=include_content,      \n                 included_files=included_files,        \n                 errors=errors,                        \n             )                                         \n             db._lock_db()                             \n return db_path                                \n def create_optional_inputs(                       \n         self, source_type: str, target_type           \n     ) -&gt; Union[Mapping[str, Mapping[str, Any]], No\u2026   \n         inputs = {}                                   \n if source_type == \"file\":                     \n             inputs[\"first_row_is_header\"] = {         \n \"type\": \"boolean\",                    \n \"optional\": True,                     \n \"doc\": \"Whether the first row of t\u2026   \n             }                                         \n if target_type == \"database\" and source_ty\u2026   \n             inputs[\"table_name\"] = {                  \n \"type\": \"string\",                     \n \"doc\": \"The name of the table in t\u2026   \n \"default\": \"imported_table\",          \n             }                                         \n return inputs                                 \n def create__database__from__table(                \n         self, source_value: Value, optional: Value\u2026   \n     ) -&gt; Any:                                         \n \"\"\"Create a database value from a table.\"\"\"   \n         table_name = optional.get_value_data(\"tabl\u2026   \n if not table_name:                            \n             table_name = \"imported_table\"             \n         table: KiaraTable = source_value.data         \n         arrow_table = table.arrow_table               \n         column_map = None                             \n         index_columns = None                          \n         sqlite_schema = create_sqlite_schema_data_\u2026   \n             table=arrow_table, index_columns=index\u2026   \n         )                                             \n         db = KiaraDatabase.create_in_temp_dir()       \n         db._unlock_db()                               \n         engine = db.get_sqlalchemy_engine()           \n         _table = sqlite_schema.create_table(table_\u2026   \n with engine.connect() as conn:                \n for batch in arrow_table.to_batches(      \n                 max_chunksize=DEFAULT_TABULAR_DATA\u2026   \n             ):                                        \n                 conn.execute(insert(_table), batch\u2026   \n                 conn.commit()                         \n         db._lock_db()                                 \n return db                                     \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.table","title":"<code>create.table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type      Descrip\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object    Value      no                   \n                                                constan\u2026                        \n                                                for this                        \n                                                module.                         \n                          defaults    object    Value      no                   \n                                                defaults                        \n                                                for this                        \n                                                module.                         \n                          ignore_e\u2026   boolean   Whether    no         false     \n                                                to                              \n                                                ignore                          \n                                                convert                         \n                                                errors                          \n                                                and omit                        \n                                                the                             \n                                                failed                          \n                                                items.                          \n                          source_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                source                          \n                                                value.                          \n                          target_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                target.                         \n                       Python class                                                                   \n  python_class_name    CreateTableModule                \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class CreateTableModule(CreateFromModule):            \n     _module_type_name = \"create.table\"                \n     _config_cls = CreateTableModuleConfig             \n def create_optional_inputs(                       \n         self, source_type: str, target_type           \n     ) -&gt; Union[Mapping[str, Mapping[str, Any]], No\u2026   \n if source_type == \"file\":                     \n return {                                  \n \"first_row_is_header\": {              \n \"type\": \"boolean\",                \n \"optional\": True,                 \n \"doc\": \"Whether the first row \u2026   \n                 }                                     \n             }                                         \n return None                                   \n def create__table__from__file(self, source_val\u2026   \n \"\"\"Create a table from a file, trying to a\u2026   \n import csv as py_csv                          \n from pyarrow import csv                       \n         input_file: FileModel = source_value.data     \n         imported_data = None                          \n         errors = []                                   \n         has_header = optional.get_value_data(\"firs\u2026   \n if has_header is None:                        \n try:                                      \n                 has_header = True                     \n with open(input_file.path, \"rt\") a\u2026   \n                     sniffer = py_csv.Sniffer()        \n                     has_header = sniffer.has_heade\u2026   \n                     csvfile.seek(0)                   \n except Exception as e:                    \n # TODO: add this to the procss log    \n                 log_message(                          \n \"csv_sniffer.error\",              \n                     file=input_file.path,             \n                     error=str(e),                     \n                     details=\"assuming csv file has\u2026   \n                 )                                     \n try:                                          \n if has_header:                            \n                 imported_data = csv.read_csv(input\u2026   \n else:                                     \n                 read_options = csv.ReadOptions(aut\u2026   \n                 imported_data = csv.read_csv(input\u2026   \n except Exception as e:                        \n             errors.append(e)                          \n if imported_data is None:                     \n raise KiaraProcessingException(           \n f\"Failed to import file '{input_fi\u2026   \n             )                                         \n # import pandas as pd                         \n # df = pd.read_csv(input_file.path)           \n # imported_data = pa.Table.from_pandas(df)    \n return KiaraTable.create_table(imported_da\u2026   \n # def create__table__from__csv_file(self, sour\u2026   \n #     \"\"\"Create a table from a csv_file value.\u2026   \n #                                                 \n #     from pyarrow import csv                     \n #                                                 \n #     input_file: FileModel = source_value.data   \n #     imported_data = csv.read_csv(input_file.\u2026   \n #                                                 \n #     # import pandas as pd                       \n #     # df = pd.read_csv(input_file.path)         \n #     # imported_data = pa.Table.from_pandas(d\u2026   \n #                                                 \n #     return KiaraTable.create_table(imported_\u2026   \n def create__table__from__file_bundle(self, sou\u2026   \n \"\"\"Create a table value from a text file_b\u2026   \n         The resulting table will have (at a minimu\u2026   \n         - id: an auto-assigned index                  \n         - rel_path: the relative path of the file \u2026   \n         - content: the text file content              \n         \"\"\"                                           \n import pyarrow as pa                          \n         bundle: FileBundle = source_value.data        \n         columns = FILE_BUNDLE_IMPORT_AVAILABLE_COL\u2026   \n         ignore_errors = self.get_config_value(\"ign\u2026   \n         file_dict = bundle.read_text_file_contents\u2026   \n # TODO: use chunks to save on memory          \n         tabular: Dict[str, List[Any]] = {}            \n for column in columns:                        \n for index, rel_path in enumerate(sorte\u2026   \n if column == \"content\":               \n                     _value: Any = file_dict[rel_pa\u2026   \n elif column == \"id\":                  \n                     _value = index                    \n elif column == \"rel_path\":            \n                     _value = rel_path                 \n else:                                 \n                     file_model = bundle.included_f\u2026   \n                     _value = getattr(file_model, c\u2026   \n                 tabular.setdefault(column, []).app\u2026   \n         table = pa.Table.from_pydict(tabular)         \n return KiaraTable.create_table(table)         \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.query.database","title":"<code>query.database</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Execute a sql query against a (sqlite) database.      \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          query       string   The         no                   \n                                               query.                           \n                       Python class                                                                   \n  python_class_name    QueryDatabaseModule              \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class QueryDatabaseModule(KiaraModule):               \n \"\"\"Execute a sql query against a (sqlite) data\u2026   \n     _config_cls = QueryDatabaseConfig                 \n     _module_type_name = \"query.database\"              \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result: Dict[str, Dict[str, Any]] = {         \n \"database\": {\"type\": \"database\", \"doc\"\u2026   \n         }                                             \n if not self.get_config_value(\"query\"):        \n             result[\"query\"] = {\"type\": \"string\", \"\u2026   \n return result                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n return {\"query_result\": {\"type\": \"table\", \u2026   \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import pyarrow as pa                          \n         database: KiaraDatabase = inputs.get_value\u2026   \n         query = self.get_config_value(\"query\")        \n if query is None:                             \n             query = inputs.get_value_data(\"query\")    \n # TODO: make this memory efficent             \n         result_columns: Dict[str, List[Any]] = {}     \n with database.get_sqlalchemy_engine().conn\u2026   \n             result = con.execute(text(query))         \n for r in result:                          \n for k, v in dict(r).items():          \n                     result_columns.setdefault(k, [\u2026   \n         table = pa.Table.from_pydict(result_column\u2026   \n         outputs.set_value(\"query_result\", table)      \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.table.pick.column","title":"<code>table.pick.column</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Pick one column from a table, returning an array.     \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          column_n\u2026   string   A           no                   \n                                               hardcoded                        \n                                               column                           \n                                               name to                          \n                                               cut.                             \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    PickColumnModule                 \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class PickColumnModule(KiaraModule):                  \n \"\"\"Pick one column from a table, returning an \u2026   \n     _module_type_name = \"table.pick.column\"           \n     _config_cls = PickColumnModuleConfig              \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         inputs: Dict[str, Any] = {\"table\": {\"type\"\u2026   \n         column_name = self.get_config_value(\"colum\u2026   \n if not column_name:                           \n             inputs[\"column_name\"] = {                 \n \"type\": \"string\",                     \n \"doc\": \"The name of the column to \u2026   \n             }                                         \n return inputs                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         outputs: Mapping[str, Any] = {\"array\": {\"t\u2026   \n return outputs                                \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import pyarrow as pa                          \n         column_name: Union[str, None] = self.get_c\u2026   \n if not column_name:                           \n             column_name = inputs.get_value_data(\"c\u2026   \n if not column_name:                           \n raise KiaraProcessingException(           \n \"Could not cut column from table: \u2026   \n             )                                         \n         table_value: Value = inputs.get_value_obj(\u2026   \n         table_metadata: KiaraTableMetadata = table\u2026   \n \"metadata.table\"                          \n         )                                             \n         available = table_metadata.table.column_na\u2026   \n if column_name not in available:              \n raise KiaraProcessingException(           \n f\"Invalid column name '{column_nam\u2026   \n             )                                         \n         table: pa.Table = table_value.data.arrow_t\u2026   \n         column = table.column(column_name)            \n         outputs.set_value(\"array\", column)            \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.table.merge","title":"<code>table.merge</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create a table from other tables and/or arrays.       \n                          This module needs configuration to be set (for        \n                          now). It's currently not possible to merge an         \n                          arbitrary number of tables/arrays, all tables to be   \n                          merged must be specified in the module                \n                          configuration.                                        \n                          Column names of the resulting table can be            \n                          controlled by the 'column_map' configuration, which   \n                          takes the desired column name as key, and a           \n                          field-name in the following format as value:          \n                        \u2022 '[inputs_schema key]' for inputs of type 'array'   \n                        \u2022 '[inputs_schema_key].orig_column_name' for         \n                       inputs of type 'table'                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          column_m\u2026   object   A map       no                   \n                                               describi\u2026                        \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          inputs_s\u2026   object   A dict      yes                  \n                                               describi\u2026                        \n                                               the                              \n                                               inputs                           \n                                               for this                         \n                                               merge                            \n                                               process.                         \n                       Python class                                                                   \n  python_class_name    MergeTableModule                 \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class MergeTableModule(KiaraModule):                  \n \"\"\"Create a table from other tables and/or arr\u2026   \n     This module needs configuration to be set (for\u2026   \n     number of tables/arrays, all tables to be merg\u2026   \n     Column names of the resulting table can be con\u2026   \n     desired column name as key, and a field-name i\u2026   \n     - '[inputs_schema key]' for inputs of type 'ar\u2026   \n     - '[inputs_schema_key].orig_column_name' for i\u2026   \n     \"\"\"                                               \n     _module_type_name = \"table.merge\"                 \n     _config_cls = MergeTableConfig                    \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         input_schema_dict = self.get_config_value(\u2026   \n return input_schema_dict                      \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         outputs = {                                   \n \"table\": {                                \n \"type\": \"table\",                      \n \"doc\": \"The merged table, includin\u2026   \n             }                                         \n         }                                             \n return outputs                                \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import pyarrow as pa                          \n         inputs_schema: Dict[str, Any] = self.get_c\u2026   \n         column_map: Dict[str, str] = self.get_conf\u2026   \n         sources = {}                                  \n for field_name in inputs_schema.keys():       \n             sources[field_name] = inputs.get_value\u2026   \n         len_dict = {}                                 \n         arrays = {}                                   \n         column_map_final = dict(column_map)           \n for source_key, table_or_array in sources.\u2026   \n if isinstance(table_or_array, KiaraTab\u2026   \n                 rows = table_or_array.num_rows        \n for name in table_or_array.column_\u2026   \n                     array_name = f\"{source_key}.{n\u2026   \n if column_map and array_name n\u2026   \n                         job_log.add_log(              \n f\"Ignoring column '{na\u2026   \n                         )                             \n continue                      \n                     column = table_or_array.arrow_\u2026   \n                     arrays[array_name] = column       \n if not column_map:                \n if name in column_map_fina\u2026   \n raise Exception(          \n f\"Can't merge tabl\u2026   \n                             )                         \n                         column_map_final[name] = a\u2026   \n elif isinstance(table_or_array, KiaraA\u2026   \n if column_map and source_key not i\u2026   \n                     job_log.add_log(                  \n f\"Ignoring array '{source_\u2026   \n                     )                                 \n continue                          \n                 rows = len(table_or_array)            \n                 arrays[source_key] = table_or_arra\u2026   \n if not column_map:                    \n if source_key in column_map_fi\u2026   \n raise Exception(              \n f\"Can't merge table, d\u2026   \n                         )                             \n                     column_map_final[source_key] =\u2026   \n else:                                     \n raise KiaraProcessingException(       \n f\"Can't merge table: invalid t\u2026   \n                 )                                     \n             len_dict[source_key] = rows               \n         all_rows = None                               \n for source_key, rows in len_dict.items():     \n if all_rows is None:                      \n                 all_rows = rows                       \n elif all_rows != rows:                    \n                 all_rows = None                       \n break                                 \n if all_rows is None:                          \n             len_str = \"\"                              \n for name, rows in len_dict.items():       \n                 len_str = f\" {name} ({rows})\"         \n raise KiaraProcessingException(           \n f\"Can't merge table, sources have \u2026   \n             )                                         \n         column_names = []                             \n         columns = []                                  \n for column_name, ref in column_map_final.i\u2026   \n             column_names.append(column_name)          \n             column = arrays[ref]                      \n             columns.append(column)                    \n         table = pa.Table.from_arrays(arrays=column\u2026   \n         outputs.set_value(\"table\", table)             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.query.table","title":"<code>query.table</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Execute a sql query against an (Arrow) table.         \n                          The default relation name for the sql query is        \n                          'data', but can be modified by the 'relation_name'    \n                          config option/input.                                  \n                          If the 'query' module config option is not set,       \n                          users can provide their own query, otherwise the      \n                          pre-set one will be used.                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         tabular                                  \n                        Labels       package: kiara_plugin.tabular            \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          query       string   The query   no                   \n                                               to                               \n                                               execute.                         \n                                               If not                           \n                                               specifie\u2026                        \n                                               the user                         \n                                               will be                          \n                                               able to                          \n                                               provide                          \n                                               their                            \n                                               own.                             \n                          relation\u2026   string   The name    no         \"data\"    \n                                               the table                        \n                                               is                               \n                                               referred                         \n                                               to in the                        \n                                               sql                              \n                                               query. If                        \n                                               not                              \n                                               specifie\u2026                        \n                                               the user                         \n                                               will be                          \n                                               able to                          \n                                               provide                          \n                                               their                            \n                                               own.                             \n                       Python class                                                                   \n  python_class_name    QueryTableSQL                    \n                        python_module_name   kiara_plugin.tabular.modules.\u2026   \n                        full_name            kiara_plugin.tabular.modules.\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class QueryTableSQL(KiaraModule):                     \n \"\"\"Execute a sql query against an (Arrow) tabl\u2026   \n     The default relation name for the sql query is\u2026   \n     If the 'query' module config option is not set\u2026   \n     one will be used.                                 \n     \"\"\"                                               \n     _module_type_name = \"query.table\"                 \n     _config_cls = QueryTableSQLModuleConfig           \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         inputs = {                                    \n \"table\": {                                \n \"type\": \"table\",                      \n \"doc\": \"The table to query\",          \n             }                                         \n         }                                             \n if self.get_config_value(\"query\") is None:    \n             inputs[\"query\"] = {                       \n \"type\": \"string\",                     \n \"doc\": \"The query, use the value o\u2026   \n             }                                         \n             inputs[\"relation_name\"] = {               \n \"type\": \"string\",                     \n \"doc\": \"The name the table is refe\u2026   \n \"default\": \"data\",                    \n             }                                         \n return inputs                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n return {\"query_result\": {\"type\": \"table\", \u2026   \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import duckdb                                 \n if self.get_config_value(\"query\") is None:    \n             _query: str = inputs.get_value_data(\"q\u2026   \n             _relation_name: str = inputs.get_value\u2026   \n else:                                         \n             _query = self.get_config_value(\"query\")   \n             _relation_name = self.get_config_value\u2026   \n if _relation_name.upper() in RESERVED_SQL_\u2026   \n raise KiaraProcessingException(           \n f\"Invalid relation name '{_relatio\u2026   \n             )                                         \n         _table: KiaraTable = inputs.get_value_data\u2026   \n         rel_from_arrow = duckdb.arrow(_table.arrow\u2026   \n         result: duckdb.DuckDBPyRelation = rel_from\u2026   \n         outputs.set_value(\"query_result\", result.a\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.create.database.from.file","title":"<code>create.database.from.file</code>","text":"Documentation <p>Create a database from a file.</p> <p>Currently, only csv files are supported.</p> Inputs field name type description required default file file The source value (of type 'file'). yes first_row_is_header boolean Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine. no Outputs field name type description required default database database The result value (of type 'database'). yes"},{"location":"info/operations/#kiara_info.operations.create.database.from.file_bundle","title":"<code>create.database.from.file_bundle</code>","text":"Documentation <p>Create a database from a file_bundle value.</p> <p>Currently, only csv files are supported, files in the source file_bundle that have different extensions will be ignored.</p> <p>Unless 'merge_into_single_table' is set to 'True' in the module configuration, each csv file will create one table in the resulting database. If this option is set, only a single table with all the values of all csv files will be created. For this to work, all csv files should follow the same schema.</p> Inputs field name type description required default file_bundle file_bundle The source value (of type 'file_bundle'). yes Outputs field name type description required default database database The result value (of type 'database'). yes"},{"location":"info/operations/#kiara_info.operations.create.database.from.table","title":"<code>create.database.from.table</code>","text":"Documentation <p>Create a database value from a table.</p> Inputs field name type description required default table table The source value (of type 'table'). yes table_name string The name of the table in the new database. no imported_table Outputs field name type description required default database database The result value (of type 'database'). yes"},{"location":"info/operations/#kiara_info.operations.create.table.from.file","title":"<code>create.table.from.file</code>","text":"Documentation <p>Create a table from a file, trying to auto-determine the format of said file.</p> Inputs field name type description required default file file The source value (of type 'file'). yes first_row_is_header boolean Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine. no Outputs field name type description required default table table The result value (of type 'table'). yes"},{"location":"info/operations/#kiara_info.operations.create.table.from.file_bundle","title":"<code>create.table.from.file_bundle</code>","text":"Documentation <p>Create a table value from a text file_bundle.</p> <p>The resulting table will have (at a minimum) the following collumns:</p> <ul> <li>id: an auto-assigned index</li> <li>rel_path: the relative path of the file (from the provided base path)</li> <li>content: the text file content</li> </ul> Inputs field name type description required default file_bundle file_bundle The source value (of type 'file_bundle'). yes Outputs field name type description required default table table The result value (of type 'table'). yes"},{"location":"info/operations/#kiara_info.operations.deserialize.array.as.python_object","title":"<code>deserialize.array.as.python_object</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default array array The value object. yes deserialization_config any Serialization-format specific configuration. no Outputs field name type description required default python_object python_object The deserialized python object instance. yes"},{"location":"info/operations/#kiara_info.operations.deserialize.database.as.python_object","title":"<code>deserialize.database.as.python_object</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default database database The value object. yes deserialization_config any Serialization-format specific configuration. no Outputs field name type description required default python_object python_object The deserialized python object instance. yes"},{"location":"info/operations/#kiara_info.operations.deserialize.table.as.python_object","title":"<code>deserialize.table.as.python_object</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default table table The value object. yes deserialization_config any Serialization-format specific configuration. no Outputs field name type description required default python_object python_object The deserialized python object instance. yes"},{"location":"info/operations/#kiara_info.operations.export.table.as.csv_file","title":"<code>export.table.as.csv_file</code>","text":"Documentation <p>Export a table as csv file.</p> Inputs field name type description required default table table A value of type 'table'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.extract.date_array.from.table","title":"<code>extract.date_array.from.table</code>","text":"Documentation <p>Extract a date array from a table column.</p> Inputs field name type description required default table table A table. yes column_name string The name of the column to extract. yes parse_date_array__force_non_null boolean If set to 'True', raise an error if any of the strings in the array can't be parsed. no True parse_date_array__min_index integer The minimum index from where to start parsing the string(s). no parse_date_array__max_index integer The maximum index until whic to parse the string(s). no parse_date_array__remove_tokens list A list of tokens/characters to replace with a single white-space before parsing the input. no [] Outputs field name type description required default date_array array The resulting array with items of a date data type. yes"},{"location":"info/operations/#kiara_info.operations.import.database.from.local_file_path","title":"<code>import.database.from.local_file_path</code>","text":"Documentation <p>Import a database from a csv file.</p> Inputs field name type description required default path string The local path to the file. yes create_database_from_file__first_row_is_header boolean Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine. no Outputs field name type description required default imported_file file The loaded files. yes database database The result value (of type 'database'). yes"},{"location":"info/operations/#kiara_info.operations.import.table.from.local_file_path","title":"<code>import.table.from.local_file_path</code>","text":"Documentation <p>Import a table from a file on the local filesystem.</p> Inputs field name type description required default path string The local path to the file. yes create_table_from_file__first_row_is_header boolean Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine. no Outputs field name type description required default imported_file file The loaded files. yes table table The result value (of type 'table'). yes"},{"location":"info/operations/#kiara_info.operations.import.table.from.local_folder_path","title":"<code>import.table.from.local_folder_path</code>","text":"Documentation <p>Import a table from a local folder containing text files.</p> Inputs field name type description required default path string The local path of the folder to import. yes Outputs field name type description required default imported_file_bundle file_bundle The imported file bundle. yes table table The result value (of type 'table'). yes"},{"location":"info/operations/#kiara_info.operations.parse.date_array","title":"<code>parse.date_array</code>","text":"Documentation <p>Create an array of date objects from an array of strings.</p> <p>This module is very simplistic at the moment, more functionality and options will be added in the future.</p> <p>At its core, this module uses the standard parser from the dateutil package to parse strings into dates. As this parser can't handle  complex strings, the input strings can be pre-processed in the following ways:</p> <ul> <li>'cut' non-relevant parts of the string (using 'min_index' &amp; 'max_index' input/config options)</li> <li>remove matching tokens from the string, and replace them with a single whitespace (using the 'remove_tokens' option)</li> </ul> <p>By default, if an input string can't be parsed this module will raise an exception. This can be prevented by setting this modules 'force_non_null' config option or input to 'False', in which case un-parsable strings will appear as 'NULL' value in the resulting array.</p> Inputs field name type description required default array array The input array. yes force_non_null boolean If set to 'True', raise an error if any of the strings in the array can't be parsed. no True min_index integer The minimum index from where to start parsing the string(s). no max_index integer The maximum index until whic to parse the string(s). no remove_tokens list A list of tokens/characters to replace with a single white-space before parsing the input. no [] Outputs field name type description required default date_array array The resulting array with items of a date data type. yes"},{"location":"info/operations/#kiara_info.operations.query.database","title":"<code>query.database</code>","text":"Documentation <p>Execute a sql query against a (sqlite) database.</p> Inputs field name type description required default database database The database to query. yes query string The query to execute. yes Outputs field name type description required default query_result table The query result. yes"},{"location":"info/operations/#kiara_info.operations.query.table","title":"<code>query.table</code>","text":"Documentation <p>Execute a sql query against an (Arrow) table.</p> <p>The default relation name for the sql query is 'data', but can be modified by the 'relation_name' config option/input.</p> <p>If the 'query' module config option is not set, users can provide their own query, otherwise the pre-set one will be used.</p> Inputs field name type description required default table table The table to query yes query string The query, use the value of the 'relation_name' input as table, e.g. 'select * from data'. yes relation_name string The name the table is referred to in the sql query. no data Outputs field name type description required default query_result table The query result. yes"},{"location":"info/operations/#kiara_info.operations.render.database.as.string","title":"<code>render.database.as.string</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value database A value of type 'database' yes render_config dict Instructions/config on how (or what) to render the provided value. no {} Outputs field name type description required default render_value_result render_value_result The rendered value, incl. some metadata. yes"},{"location":"info/operations/#kiara_info.operations.render.database.as.terminal_renderable","title":"<code>render.database.as.terminal_renderable</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value database A value of type 'database' yes render_config dict Instructions/config on how (or what) to render the provided value. no {} Outputs field name type description required default render_value_result render_value_result The rendered value, incl. some metadata. yes"},{"location":"info/operations/#kiara_info.operations.render.table.as.string","title":"<code>render.table.as.string</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value table A value of type 'table' yes render_config dict Instructions/config on how (or what) to render the provided value. no {} Outputs field name type description required default render_value_result render_value_result The rendered value, incl. some metadata. yes"},{"location":"info/operations/#kiara_info.operations.render.table.as.terminal_renderable","title":"<code>render.table.as.terminal_renderable</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value table A value of type 'table' yes render_config dict Instructions/config on how (or what) to render the provided value. no {} Outputs field name type description required default render_value_result render_value_result The rendered value, incl. some metadata. yes"},{"location":"info/operations/#kiara_info.operations.table.pick.column","title":"<code>table.pick.column</code>","text":"Documentation <p>Pick one column from a table, returning an array.</p> Inputs field name type description required default table table A table. yes column_name string The name of the column to extract. yes Outputs field name type description required default array array The column. yes"},{"location":"info/operations/#kiara_info.operations.table_filter.drop_columns","title":"<code>table_filter.drop_columns</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value table A value of type 'table'. yes columns list The name of the columns to include. no ignore_invalid_column_names boolean Whether to ignore invalid column names. no True Outputs field name type description required default value table The filtered value. yes"},{"location":"info/operations/#kiara_info.operations.table_filter.select_columns","title":"<code>table_filter.select_columns</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value table A value of type 'table'. yes columns list The name of the columns to include. no ignore_invalid_column_names boolean Whether to ignore invalid column names. no True Outputs field name type description required default value table The filtered value. yes"},{"location":"info/operations/#kiara_info.operations.table_filter.select_rows","title":"<code>table_filter.select_rows</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value table A value of type 'table'. yes match string The string token to match. no case_insensitive boolean Whether to ignore case. no True Outputs field name type description required default value table The filtered value. yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>tabular<ul> <li>data_types<ul> <li>array</li> <li>db</li> <li>table</li> </ul> </li> <li>defaults</li> <li>models<ul> <li>array</li> <li>db</li> <li>table</li> </ul> </li> <li>modules<ul> <li>array</li> <li>db</li> <li>table<ul> <li>filters</li> </ul> </li> </ul> </li> <li>pipelines</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/tabular/__init__/","title":"tabular","text":"<p>Top-level package for kiara_plugin.tabular.</p>"},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara modules for: tabular', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.tabular'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.tabular/'}}, 'tags': ['tabular'], 'labels': {'package': 'kiara_plugin.tabular'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.tabular.modules')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.tabular.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.tabular.data_types')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.tabular.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/__init__/#kiara_plugin.tabular.get_version","title":"<code>get_version()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/__init__.py</code> <pre><code>def get_version():\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/defaults/","title":"defaults","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.DEFAULT_TABULAR_DATA_CHUNK_SIZE","title":"<code>DEFAULT_TABULAR_DATA_CHUNK_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.SqliteDataType","title":"<code>SqliteDataType = Literal['NULL', 'INTEGER', 'REAL', 'TEXT', 'BLOB', 'FLOAT']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.SQLITE_DATA_TYPE","title":"<code>SQLITE_DATA_TYPE: Tuple[SqliteDataType, ...] = typing.get_args(SqliteDataType)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.SQLITE_SQLALCHEMY_TYPE_MAP","title":"<code>SQLITE_SQLALCHEMY_TYPE_MAP: Dict[SqliteDataType, Type] = {'INTEGER': INTEGER, 'FLOAT': FLOAT, 'REAL': FLOAT, 'TEXT': TEXT, 'BLOB': BLOB}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.SQLALCHEMY_SQLITE_TYPE_MAP","title":"<code>SQLALCHEMY_SQLITE_TYPE_MAP: Dict[Type, SqliteDataType] = {INTEGER: 'INTEGER', FLOAT: 'REAL', TEXT: 'TEXT', BLOB: 'BLOB', BOOLEAN: 'INTEGER', VARCHAR: 'TEXT'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/defaults/#kiara_plugin.tabular.defaults.RESERVED_SQL_KEYWORDS","title":"<code>RESERVED_SQL_KEYWORDS = ['ALL', 'AND', 'ARRAY', 'AS', 'BETWEEN', 'BOTH', 'CASE', 'CHECK', 'CONSTRAINT', 'CROSS', 'CURRENT', 'CURRENT', 'CURRENT', 'CURRENT', 'CURRENT', 'CURRENT', 'DISTINCT', 'EXCEPT', 'EXISTS', 'FALSE', 'FETCH', 'FILTER', 'FOR', 'FOREIGN', 'FROM', 'FULL', 'GROUP', 'GROUPS', 'HAVING', 'IF', 'ILIKE', 'IN', 'INNER', 'INTERSECT', 'INTERSECTS', 'INTERVAL', 'IS', 'JOIN', 'LEADING', 'LEFT', 'LIKE', 'LIMIT', 'LOCALTIME', 'LOCALTIMESTAMP', 'MINUS', 'NATURAL', 'NOT', 'NULL', 'OFFSET', 'ON', 'OR', 'ORDER', 'OVER', 'PARTITION', 'PRIMARY', 'QUALIFY', 'RANGE', 'REGEXP', 'RIGHT', 'ROW', '_ROWID', 'ROWNUM', 'ROWS', 'SELECT', 'SYSDATE', 'SYSTIME', 'SYSTIMESTAMP', 'TABLE', 'TODAY', 'TOP', 'TRAILING', 'TRUE', 'UNION', 'UNIQUE', 'UNKNOWN', 'USING', 'VALUES', 'WHERE', 'WINDOW', 'WITH']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/utils/","title":"utils","text":""},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.insert_db_table_from_file_bundle","title":"<code>insert_db_table_from_file_bundle(database: KiaraDatabase, file_bundle: FileBundle, table_name: str = 'file_items', include_content: bool = True, included_files: Union[None, Mapping[str, bool]] = None, errors: Union[Mapping[str, Union[str, None]], None] = None)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def insert_db_table_from_file_bundle(\n    database: KiaraDatabase,\n    file_bundle: FileBundle,\n    table_name: str = \"file_items\",\n    include_content: bool = True,\n    included_files: Union[None, Mapping[str, bool]] = None,\n    errors: Union[Mapping[str, Union[str, None]], None] = None,\n):\n\n    # TODO: check if table with that name exists\n\n    from sqlalchemy import (\n        Boolean,\n        Column,\n        Integer,\n        MetaData,\n        String,\n        Table,\n        Text,\n        insert,\n    )\n    from sqlalchemy.engine import Engine\n\n    # if db_file_path is None:\n    #     temp_f = tempfile.mkdtemp()\n    #     db_file_path = os.path.join(temp_f, \"db.sqlite\")\n    #\n    #     def cleanup():\n    #         shutil.rmtree(db_file_path, ignore_errors=True)\n    #\n    #     atexit.register(cleanup)\n\n    metadata_obj = MetaData()\n\n    file_items = Table(\n        table_name,\n        metadata_obj,\n        Column(\"id\", Integer, primary_key=True),\n        Column(\"size\", Integer(), nullable=False),\n        Column(\"mime_type\", String(length=64), nullable=False),\n        Column(\"rel_path\", String(), nullable=False),\n        Column(\"file_name\", String(), nullable=False),\n        Column(\"content\", Text(), nullable=not include_content),\n        Column(\"included_in_bundle\", Boolean(), nullable=included_files is None),\n        Column(\"error\", Text(), nullable=True),\n    )\n\n    engine: Engine = database.get_sqlalchemy_engine()\n    metadata_obj.create_all(engine)\n\n    if included_files is None:\n        included_files = {}\n    if errors is None:\n        errors = {}\n\n    with engine.connect() as con:\n\n        # TODO: commit in batches for better performance\n\n        for index, rel_path in enumerate(sorted(file_bundle.included_files.keys())):\n            f: FileModel = file_bundle.included_files[rel_path]\n            if include_content:\n                content: Union[str, None] = f.read_text()  # type: ignore\n            else:\n                content = None\n\n            included = included_files.get(rel_path, None)\n            error = errors.get(rel_path, None)\n            _values = {\n                \"id\": index,\n                \"size\": f.size,\n                \"mime_type\": f.mime_type,\n                \"rel_path\": rel_path,\n                \"file_name\": f.file_name,\n                \"content\": content,\n                \"included_in_bundle\": included,\n                \"error\": error,\n            }\n\n            stmt = insert(file_items).values(**_values)\n            con.execute(stmt)\n        con.commit()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.convert_arrow_type_to_sqlite","title":"<code>convert_arrow_type_to_sqlite(data_type: str) -&gt; SqliteDataType</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def convert_arrow_type_to_sqlite(data_type: str) -&gt; SqliteDataType:\n\n    if data_type.startswith(\"int\") or data_type.startswith(\"uint\"):\n        return \"INTEGER\"\n\n    if (\n        data_type.startswith(\"float\")\n        or data_type.startswith(\"decimal\")\n        or data_type.startswith(\"double\")\n    ):\n        return \"REAL\"\n\n    if data_type.startswith(\"time\") or data_type.startswith(\"date\"):\n        return \"TEXT\"\n\n    if data_type == \"bool\":\n        return \"INTEGER\"\n\n    if data_type in [\"string\", \"utf8\", \"large_string\", \"large_utf8\"]:\n        return \"TEXT\"\n\n    if data_type in [\"binary\", \"large_binary\"]:\n        return \"BLOB\"\n\n    raise Exception(f\"Can't convert to sqlite type: {data_type}\")\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.convert_arrow_column_types_to_sqlite","title":"<code>convert_arrow_column_types_to_sqlite(table: pa.Table) -&gt; Dict[str, SqliteDataType]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def convert_arrow_column_types_to_sqlite(\n    table: \"pa.Table\",\n) -&gt; Dict[str, SqliteDataType]:\n\n    result: Dict[str, SqliteDataType] = {}\n    for column_name in table.column_names:\n        field = table.field(column_name)\n        sqlite_type = convert_arrow_type_to_sqlite(str(field.type))\n        result[column_name] = sqlite_type\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.create_sqlite_schema_data_from_arrow_table","title":"<code>create_sqlite_schema_data_from_arrow_table(table: pa.Table, column_map: Union[Mapping[str, str], None] = None, index_columns: Union[Iterable[str], None] = None, nullable_columns: Union[Iterable[str], None] = None, unique_columns: Union[Iterable[str], None] = None, primary_key: Union[str, None] = None) -&gt; SqliteTableSchema</code>","text":"<p>Create a sql schema statement from an Arrow table object.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> <p>the Arrow table object</p> required <code>column_map</code> <code>Union[Mapping[str, str], None]</code> <p>a map that contains column names that should be changed in the new table</p> <code>None</code> <code>index_columns</code> <code>Union[Iterable[str], None]</code> <p>a list of column names (after mapping) to create module_indexes for</p> <code>None</code> <code>extra_column_info</code> <p>a list of extra schema instructions per column name (after mapping)</p> required Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def create_sqlite_schema_data_from_arrow_table(\n    table: \"pa.Table\",\n    column_map: Union[Mapping[str, str], None] = None,\n    index_columns: Union[Iterable[str], None] = None,\n    nullable_columns: Union[Iterable[str], None] = None,\n    unique_columns: Union[Iterable[str], None] = None,\n    primary_key: Union[str, None] = None,\n) -&gt; SqliteTableSchema:\n\"\"\"Create a sql schema statement from an Arrow table object.\n\n    Arguments:\n        table: the Arrow table object\n        column_map: a map that contains column names that should be changed in the new table\n        index_columns: a list of column names (after mapping) to create module_indexes for\n        extra_column_info: a list of extra schema instructions per column name (after mapping)\n    \"\"\"\n\n    columns = convert_arrow_column_types_to_sqlite(table=table)\n\n    if column_map is None:\n        column_map = {}\n\n    temp: Dict[str, SqliteDataType] = {}\n\n    if index_columns is None:\n        index_columns = []\n\n    if nullable_columns is None:\n        nullable_columns = []\n\n    if unique_columns is None:\n        unique_columns = []\n\n    for cn, sqlite_data_type in columns.items():\n        if cn in column_map.keys():\n            new_key = column_map[cn]\n            index_columns = [\n                x if x not in column_map.keys() else column_map[x]\n                for x in index_columns\n            ]\n            unique_columns = [\n                x if x not in column_map.keys() else column_map[x]\n                for x in unique_columns\n            ]\n            nullable_columns = [\n                x if x not in column_map.keys() else column_map[x]\n                for x in nullable_columns\n            ]\n        else:\n            new_key = cn\n\n        temp[new_key] = sqlite_data_type\n\n    columns = temp\n    if not columns:\n        raise Exception(\"Resulting table schema has no columns.\")\n    else:\n        for ic in index_columns:\n            if ic not in columns.keys():\n                raise Exception(\n                    f\"Can't create schema, requested index column name not available: {ic}\"\n                )\n\n    schema = SqliteTableSchema(\n        columns=columns,\n        index_columns=index_columns,\n        nullable_columns=nullable_columns,\n        unique_columns=unique_columns,\n        primary_key=primary_key,\n    )\n    return schema\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.create_sqlite_table_from_tabular_file","title":"<code>create_sqlite_table_from_tabular_file(target_db_file: str, file_item: FileModel, table_name: Union[str, None] = None, is_csv: bool = True, is_tsv: bool = False, is_nl: bool = False, primary_key_column_names: Union[Iterable[str], None] = None, flatten_nested_json_objects: bool = False, csv_delimiter: Union[str, None] = None, quotechar: Union[str, None] = None, sniff: bool = True, no_headers: bool = False, encoding: str = 'utf-8', batch_size: int = 100, detect_types: bool = True)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def create_sqlite_table_from_tabular_file(\n    target_db_file: str,\n    file_item: FileModel,\n    table_name: Union[str, None] = None,\n    is_csv: bool = True,\n    is_tsv: bool = False,\n    is_nl: bool = False,\n    primary_key_column_names: Union[Iterable[str], None] = None,\n    flatten_nested_json_objects: bool = False,\n    csv_delimiter: Union[str, None] = None,\n    quotechar: Union[str, None] = None,\n    sniff: bool = True,\n    no_headers: bool = False,\n    encoding: str = \"utf-8\",\n    batch_size: int = 100,\n    detect_types: bool = True,\n):\n\n    if not table_name:\n        table_name = file_item.file_name_without_extension\n\n    f = open(file_item.path, \"rb\")\n\n    try:\n        insert_upsert_implementation_patched(\n            path=target_db_file,\n            table=table_name,\n            file=f,\n            pk=primary_key_column_names,\n            flatten=flatten_nested_json_objects,\n            nl=is_nl,\n            csv=is_csv,\n            tsv=is_tsv,\n            lines=False,\n            text=False,\n            convert=None,\n            imports=None,\n            delimiter=csv_delimiter,\n            quotechar=quotechar,\n            sniff=sniff,\n            no_headers=no_headers,\n            encoding=encoding,\n            batch_size=batch_size,\n            alter=False,\n            upsert=False,\n            ignore=False,\n            replace=False,\n            truncate=False,\n            not_null=None,\n            default=None,\n            detect_types=detect_types,\n            analyze=False,\n            load_extension=None,\n            silent=True,\n            bulk_sql=None,\n        )\n    except Exception as e:\n\n        log_exception(e)\n        raise e\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/utils/#kiara_plugin.tabular.utils.insert_upsert_implementation_patched","title":"<code>insert_upsert_implementation_patched(path, table, file, pk, flatten, nl, csv, tsv, lines, text, convert, imports, delimiter, quotechar, sniff, no_headers, encoding, batch_size, alter, upsert, ignore = False, replace = False, truncate = False, not_null = None, default = None, detect_types = None, analyze = False, load_extension = None, silent = False, bulk_sql = None, functions = None)</code>","text":"<p>Patched version of the insert/upsert implementation from the sqlite-utils package.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/utils.py</code> <pre><code>def insert_upsert_implementation_patched(\n    path,\n    table,\n    file,\n    pk,\n    flatten,\n    nl,\n    csv,\n    tsv,\n    lines,\n    text,\n    convert,\n    imports,\n    delimiter,\n    quotechar,\n    sniff,\n    no_headers,\n    encoding,\n    batch_size,\n    alter,\n    upsert,\n    ignore=False,\n    replace=False,\n    truncate=False,\n    not_null=None,\n    default=None,\n    detect_types=None,\n    analyze=False,\n    load_extension=None,\n    silent=False,\n    bulk_sql=None,\n    functions=None,\n):\n\"\"\"Patched version of the insert/upsert implementation from the sqlite-utils package.\"\"\"\n\n    import rich_click as click\n\n    db = sqlite_utils.Database(path)\n    _load_extensions(db, load_extension)\n    if functions:\n        _register_functions(db, functions)\n    if (delimiter or quotechar or sniff or no_headers) and not tsv:\n        csv = True\n    if (nl + csv + tsv) &gt;= 2:\n        raise click.ClickException(\"Use just one of --nl, --csv or --tsv\")\n    if (csv or tsv) and flatten:\n        raise click.ClickException(\"--flatten cannot be used with --csv or --tsv\")\n    if encoding and not (csv or tsv):\n        raise click.ClickException(\"--encoding must be used with --csv or --tsv\")\n    if pk and len(pk) == 1:\n        pk = pk[0]\n    encoding = encoding or \"utf-8-sig\"\n\n    # The --sniff option needs us to buffer the file to peek ahead\n    sniff_buffer = None\n    if sniff:\n        sniff_buffer = io.BufferedReader(file, buffer_size=4096)\n        decoded = io.TextIOWrapper(sniff_buffer, encoding=encoding)\n    else:\n        decoded = io.TextIOWrapper(file, encoding=encoding)\n\n    try:\n        tracker = None\n        with file_progress(decoded, silent=silent) as decoded:\n            if csv or tsv:\n                if sniff:\n                    # Read first 2048 bytes and use that to detect\n                    first_bytes = sniff_buffer.peek(2048)\n                    dialect = csv_std.Sniffer().sniff(\n                        first_bytes.decode(encoding, \"ignore\")\n                    )\n                else:\n                    dialect = \"excel-tab\" if tsv else \"excel\"\n                csv_reader_args = {\"dialect\": dialect}\n                if delimiter:\n                    csv_reader_args[\"delimiter\"] = delimiter\n                if quotechar:\n                    csv_reader_args[\"quotechar\"] = quotechar\n                reader = csv_std.reader(decoded, **csv_reader_args)\n                first_row = next(reader)\n                if no_headers:\n                    headers = [\n                        \"untitled_{}\".format(i + 1) for i in range(len(first_row))\n                    ]\n\n                    reader = itertools.chain([first_row], reader)\n                else:\n                    headers = first_row\n                docs = (dict(zip(headers, row)) for row in reader)\n                if detect_types:\n                    tracker = TypeTracker()\n                    docs = tracker.wrap(docs)\n            elif lines:\n                docs = ({\"line\": line.strip()} for line in decoded)\n            elif text:\n                docs = ({\"text\": decoded.read()},)\n            else:\n                try:\n                    if nl:\n                        docs = (json.loads(line) for line in decoded if line.strip())\n                    else:\n                        docs = json.load(decoded)\n                        if isinstance(docs, dict):\n                            docs = [docs]\n                except json.decoder.JSONDecodeError:\n                    raise click.ClickException(\n                        \"Invalid JSON - use --csv for CSV or --tsv for TSV files\"\n                    )\n                if flatten:\n                    docs = (_flatten(doc) for doc in docs)\n\n        if convert:\n            variable = \"row\"\n            if lines:\n                variable = \"line\"\n            elif text:\n                variable = \"text\"\n            fn = _compile_code(convert, imports, variable=variable)\n            if lines:\n                docs = (fn(doc[\"line\"]) for doc in docs)\n            elif text:\n                # Special case: this is allowed to be an iterable\n                text_value = list(docs)[0][\"text\"]\n                fn_return = fn(text_value)\n                if isinstance(fn_return, dict):\n                    docs = [fn_return]\n                else:\n                    try:\n                        docs = iter(fn_return)\n                    except TypeError:\n                        raise click.ClickException(\n                            \"--convert must return dict or iterator\"\n                        )\n            else:\n                docs = (fn(doc) or doc for doc in docs)\n\n        extra_kwargs = {\n            \"ignore\": ignore,\n            \"replace\": replace,\n            \"truncate\": truncate,\n            \"analyze\": analyze,\n        }\n        if not_null:\n            extra_kwargs[\"not_null\"] = set(not_null)\n        if default:\n            extra_kwargs[\"defaults\"] = dict(default)\n        if upsert:\n            extra_kwargs[\"upsert\"] = upsert\n\n        # docs should all be dictionaries\n        docs = (verify_is_dict(doc) for doc in docs)\n\n        # Apply {\"$base64\": true, ...} decoding, if needed\n        docs = (decode_base64_values(doc) for doc in docs)\n\n        # For bulk_sql= we use cursor.executemany() instead\n        if bulk_sql:\n            if batch_size:\n                doc_chunks = chunks(docs, batch_size)\n            else:\n                doc_chunks = [docs]\n            for doc_chunk in doc_chunks:\n                with db.conn:\n                    db.conn.cursor().executemany(bulk_sql, doc_chunk)\n            return\n\n        try:\n            db[table].insert_all(\n                docs, pk=pk, batch_size=batch_size, alter=alter, **extra_kwargs\n            )\n        except Exception as e:\n\n            if (\n                isinstance(e, OperationalError)\n                and e.args\n                and \"has no column named\" in e.args[0]\n            ):\n                raise click.ClickException(\n                    \"{}\\n\\nTry using --alter to add additional columns\".format(\n                        e.args[0]\n                    )\n                )\n            # If we can find sql= and parameters= arguments, show those\n            variables = _find_variables(e.__traceback__, [\"sql\", \"parameters\"])\n            if \"sql\" in variables and \"parameters\" in variables:\n                raise click.ClickException(\n                    \"{}\\n\\nsql = {}\\nparameters = {}\".format(\n                        str(e), variables[\"sql\"], variables[\"parameters\"]\n                    )\n                )\n            else:\n                raise e\n        if tracker is not None:\n            db[table].transform(types=tracker.types)\n    finally:\n        decoded.close()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/__init__/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.tabular</code> package.</p>"},{"location":"reference/kiara_plugin/tabular/data_types/array/","title":"array","text":""},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType","title":"<code>ArrayType</code>","text":"<p>         Bases: <code>AnyType[KiaraArray, DataTypeConfig]</code></p> <p>An array, in most cases used as a column within a table.</p> <p>Internally, this type uses the KiaraArray wrapper class to manage array data. This wrapper class, in turn, uses an Apache Arrow Array to store the data in memory (and on disk).</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>class ArrayType(AnyType[KiaraArray, DataTypeConfig]):\n\"\"\"An array, in most cases used as a column within a table.\n\n    Internally, this type uses the [KiaraArray][kiara_plugin.tabular.models.array.KiaraArray] wrapper class to manage array data. This wrapper class, in turn, uses an [Apache Arrow](https://arrow.apache.org) [Array](https://arrow.apache.org/docs/python/generated/pyarrow.Array.html#pyarrow.Array) to store the data in memory (and on disk).\n    \"\"\"\n\n    _data_type_name = \"array\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return KiaraArray\n\n    def parse_python_obj(self, data: Any) -&gt; KiaraArray:\n\n        return KiaraArray.create_array(data)\n\n    def _validate(cls, value: Any) -&gt; None:\n\n        if not isinstance(value, (KiaraArray)):\n            raise Exception(\n                f\"Invalid type '{type(value).__name__}', must be an instance of the 'KiaraArray' class.\"\n            )\n\n    def serialize(self, data: KiaraArray) -&gt; SerializedData:\n\n        import pyarrow as pa\n\n        # TODO: make sure temp dir is in the same partition as file store\n        temp_f = tempfile.mkdtemp()\n\n        def cleanup():\n            shutil.rmtree(temp_f, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        column: pa.Array = data.arrow_array\n        file_name = os.path.join(temp_f, \"array.arrow\")\n\n        store_array(array_obj=column, file_name=file_name, column_name=\"array\")\n\n        chunks = {\"array.arrow\": {\"type\": \"file\", \"codec\": \"raw\", \"file\": file_name}}\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": chunks,\n            \"serialization_profile\": \"feather\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"load.array\",\n                        \"module_config\": {\n                            \"value_type\": \"array\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"feather\",\n                        },\n                    }\n                },\n            },\n        }\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        import pyarrow as pa\n\n        array: pa.Array = value.data.arrow_array\n\n        temp_table = pa.Table.from_arrays(arrays=[array], names=[\"array\"])\n        atw = ArrowTabularWrap(temp_table)\n        result = atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n            show_table_header=False,\n        )\n\n        return result\n\n    def pretty_print_as__string(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        import pyarrow as pa\n\n        array: pa.Array = value.data.arrow_array\n\n        temp_table = pa.Table.from_arrays(arrays=[array], names=[\"array\"])\n        atw = ArrowTabularWrap(temp_table)\n        result = atw.as_string(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return KiaraArray\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; KiaraArray</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; KiaraArray:\n\n    return KiaraArray.create_array(data)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType.serialize","title":"<code>serialize(data: KiaraArray) -&gt; SerializedData</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>def serialize(self, data: KiaraArray) -&gt; SerializedData:\n\n    import pyarrow as pa\n\n    # TODO: make sure temp dir is in the same partition as file store\n    temp_f = tempfile.mkdtemp()\n\n    def cleanup():\n        shutil.rmtree(temp_f, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    column: pa.Array = data.arrow_array\n    file_name = os.path.join(temp_f, \"array.arrow\")\n\n    store_array(array_obj=column, file_name=file_name, column_name=\"array\")\n\n    chunks = {\"array.arrow\": {\"type\": \"file\", \"codec\": \"raw\", \"file\": file_name}}\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": chunks,\n        \"serialization_profile\": \"feather\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"load.array\",\n                    \"module_config\": {\n                        \"value_type\": \"array\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"feather\",\n                    },\n                }\n            },\n        },\n    }\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    import pyarrow as pa\n\n    array: pa.Array = value.data.arrow_array\n\n    temp_table = pa.Table.from_arrays(arrays=[array], names=[\"array\"])\n    atw = ArrowTabularWrap(temp_table)\n    result = atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n        show_table_header=False,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.ArrayType.pretty_print_as__string","title":"<code>pretty_print_as__string(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>def pretty_print_as__string(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    import pyarrow as pa\n\n    array: pa.Array = value.data.arrow_array\n\n    temp_table = pa.Table.from_arrays(arrays=[array], names=[\"array\"])\n    atw = ArrowTabularWrap(temp_table)\n    result = atw.as_string(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/data_types/array/#kiara_plugin.tabular.data_types.array.store_array","title":"<code>store_array(array_obj: pa.Array, file_name: str, column_name: str = 'array')</code>","text":"<p>Utility methdo to stora an array to a file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/array.py</code> <pre><code>def store_array(array_obj: \"pa.Array\", file_name: str, column_name: \"str\" = \"array\"):\n\"\"\"Utility methdo to stora an array to a file.\"\"\"\n\n    import pyarrow as pa\n    from pyarrow import ChunkedArray\n\n    schema = pa.schema([pa.field(column_name, array_obj.type)])\n\n    # TODO: support non-single chunk columns\n    with pa.OSFile(file_name, \"wb\") as sink:\n        with pa.ipc.new_file(sink, schema=schema) as writer:\n            if isinstance(array_obj, ChunkedArray):\n                for chunk in array_obj.chunks:\n                    batch = pa.record_batch([chunk], schema=schema)\n                    writer.write(batch)\n            else:\n                raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/","title":"db","text":""},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap","title":"<code>SqliteTabularWrap</code>","text":"<p>         Bases: <code>TabularWrap</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>class SqliteTabularWrap(TabularWrap):\n    def __init__(\n        self,\n        engine: \"Engine\",\n        table_name: str,\n        sort_column_names: Union[None, Iterable[str]] = None,\n        sort_reverse: bool = False,\n    ):\n        self._engine: Engine = engine\n        self._table_name: str = table_name\n        self._sort_column_names: Union[Iterable[str], None] = sort_column_names\n        self._sort_reverse: bool = sort_reverse\n        super().__init__()\n\n    def retrieve_number_of_rows(self) -&gt; int:\n\n        from sqlalchemy import text\n\n        with self._engine.connect() as con:\n            result = con.execute(text(f'SELECT count(*) from \"{self._table_name}\"'))\n            num_rows = result.fetchone()[0]\n\n        return num_rows\n\n    def retrieve_column_names(self) -&gt; Iterable[str]:\n\n        from sqlalchemy import inspect\n\n        engine = self._engine\n        inspector = inspect(engine)\n        columns = inspector.get_columns(self._table_name)\n        result = [column[\"name\"] for column in columns]\n        return result\n\n    def slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n\n        from sqlalchemy import text\n\n        query = f'SELECT * FROM \"{self._table_name}\"'\n\n        if self._sort_column_names:\n            query = f\"{query} ORDER BY \"\n            order = []\n            for col in self._sort_column_names:\n                if self._sort_reverse:\n                    order.append(f\"{col} DESC\")\n                else:\n                    order.append(f\"{col} ASC\")\n            query = f\"{query} {', '.join(order)}\"\n\n        if length:\n            query = f\"{query} LIMIT {length}\"\n        else:\n            query = f\"{query} LIMIT {self.num_rows}\"\n        if offset &gt; 0:\n            query = f\"{query} OFFSET {offset}\"\n\n        with self._engine.connect() as con:\n            result = con.execute(text(query))\n            result_dict: Dict[str, List[Any]] = {}\n            for cn in self.column_names:\n                result_dict[cn] = []\n            for r in result:\n                for i, cn in enumerate(self.column_names):\n                    result_dict[cn].append(r[i])\n\n        return DictTabularWrap(result_dict)\n\n    def to_pydict(self) -&gt; Mapping:\n\n        from sqlalchemy import text\n\n        query = f'SELECT * FROM \"{self._table_name}\"'\n\n        with self._engine.connect() as con:\n            result = con.execute(text(query))\n            result_dict: Dict[str, List[Any]] = {}\n            for cn in self.column_names:\n                result_dict[cn] = []\n            for r in result:\n                for i, cn in enumerate(self.column_names):\n                    result_dict[cn].append(r[i])\n\n        return result_dict\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap.retrieve_number_of_rows","title":"<code>retrieve_number_of_rows() -&gt; int</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def retrieve_number_of_rows(self) -&gt; int:\n\n    from sqlalchemy import text\n\n    with self._engine.connect() as con:\n        result = con.execute(text(f'SELECT count(*) from \"{self._table_name}\"'))\n        num_rows = result.fetchone()[0]\n\n    return num_rows\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap.retrieve_column_names","title":"<code>retrieve_column_names() -&gt; Iterable[str]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def retrieve_column_names(self) -&gt; Iterable[str]:\n\n    from sqlalchemy import inspect\n\n    engine = self._engine\n    inspector = inspect(engine)\n    columns = inspector.get_columns(self._table_name)\n    result = [column[\"name\"] for column in columns]\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap.slice","title":"<code>slice(offset: int = 0, length: Union[int, None] = None) -&gt; TabularWrap</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n\n    from sqlalchemy import text\n\n    query = f'SELECT * FROM \"{self._table_name}\"'\n\n    if self._sort_column_names:\n        query = f\"{query} ORDER BY \"\n        order = []\n        for col in self._sort_column_names:\n            if self._sort_reverse:\n                order.append(f\"{col} DESC\")\n            else:\n                order.append(f\"{col} ASC\")\n        query = f\"{query} {', '.join(order)}\"\n\n    if length:\n        query = f\"{query} LIMIT {length}\"\n    else:\n        query = f\"{query} LIMIT {self.num_rows}\"\n    if offset &gt; 0:\n        query = f\"{query} OFFSET {offset}\"\n\n    with self._engine.connect() as con:\n        result = con.execute(text(query))\n        result_dict: Dict[str, List[Any]] = {}\n        for cn in self.column_names:\n            result_dict[cn] = []\n        for r in result:\n            for i, cn in enumerate(self.column_names):\n                result_dict[cn].append(r[i])\n\n    return DictTabularWrap(result_dict)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.SqliteTabularWrap.to_pydict","title":"<code>to_pydict() -&gt; Mapping</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def to_pydict(self) -&gt; Mapping:\n\n    from sqlalchemy import text\n\n    query = f'SELECT * FROM \"{self._table_name}\"'\n\n    with self._engine.connect() as con:\n        result = con.execute(text(query))\n        result_dict: Dict[str, List[Any]] = {}\n        for cn in self.column_names:\n            result_dict[cn] = []\n        for r in result:\n            for i, cn in enumerate(self.column_names):\n                result_dict[cn].append(r[i])\n\n    return result_dict\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType","title":"<code>DatabaseType</code>","text":"<p>         Bases: <code>AnyType[KiaraDatabase, DataTypeConfig]</code></p> <p>A database, containing one or several tables.</p> <p>This is backed by the KiaraDatabase class to manage the stored data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>class DatabaseType(AnyType[KiaraDatabase, DataTypeConfig]):\n\"\"\"A database, containing one or several tables.\n\n    This is backed by the [KiaraDatabase][kiara_plugin.tabular.models.db.KiaraDatabase] class to manage\n    the stored data.\n    \"\"\"\n\n    _data_type_name = \"database\"\n\n    @classmethod\n    def python_class(self) -&gt; Type[KiaraDatabase]:\n        return KiaraDatabase\n\n    def parse_python_obj(self, data: Any) -&gt; KiaraDatabase:\n\n        if isinstance(data, Path):\n            data = data.as_posix()\n\n        if isinstance(data, str):\n            if not os.path.exists(data):\n                raise ValueError(\n                    f\"Can't create database from path '{data}': path does not exist.\"\n                )\n\n            return KiaraDatabase(db_file_path=data)\n\n        return data\n\n    def _validate(cls, value: Any) -&gt; None:\n\n        if not isinstance(value, (KiaraDatabase)):\n            raise ValueError(\n                f\"Invalid type '{type(value).__name__}', must be an instance of the 'KiaraDatabase' class.\"\n            )\n\n    def serialize(self, data: KiaraDatabase) -&gt; SerializedData:\n\n        chunks = {\n            \"db.sqlite\": {\"type\": \"file\", \"codec\": \"raw\", \"file\": data.db_file_path}\n        }\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": chunks,\n            \"serialization_profile\": \"copy\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"load.database\",\n                        \"module_config\": {\n                            \"value_type\": self.data_type_name,\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"copy\",\n                        },\n                    }\n                },\n            },\n        }\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        db: KiaraDatabase = value.data\n\n        result: List[Any] = [\"\"]\n        for table_name in db.table_names:\n            atw = SqliteTabularWrap(\n                engine=db.get_sqlalchemy_engine(), table_name=table_name\n            )\n            pretty = atw.as_terminal_renderable(\n                rows_head=half_lines,\n                rows_tail=half_lines,\n                max_row_height=max_row_height,\n                max_cell_length=max_cell_length,\n            )\n            result.append(f\"[b]Table[/b]: [i]{table_name}[/i]\")\n            result.append(pretty)\n\n        return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType.python_class","title":"<code>python_class() -&gt; Type[KiaraDatabase]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>@classmethod\ndef python_class(self) -&gt; Type[KiaraDatabase]:\n    return KiaraDatabase\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; KiaraDatabase</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; KiaraDatabase:\n\n    if isinstance(data, Path):\n        data = data.as_posix()\n\n    if isinstance(data, str):\n        if not os.path.exists(data):\n            raise ValueError(\n                f\"Can't create database from path '{data}': path does not exist.\"\n            )\n\n        return KiaraDatabase(db_file_path=data)\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType.serialize","title":"<code>serialize(data: KiaraDatabase) -&gt; SerializedData</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def serialize(self, data: KiaraDatabase) -&gt; SerializedData:\n\n    chunks = {\n        \"db.sqlite\": {\"type\": \"file\", \"codec\": \"raw\", \"file\": data.db_file_path}\n    }\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": chunks,\n        \"serialization_profile\": \"copy\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"load.database\",\n                    \"module_config\": {\n                        \"value_type\": self.data_type_name,\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"copy\",\n                    },\n                }\n            },\n        },\n    }\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/db/#kiara_plugin.tabular.data_types.db.DatabaseType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/db.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    db: KiaraDatabase = value.data\n\n    result: List[Any] = [\"\"]\n    for table_name in db.table_names:\n        atw = SqliteTabularWrap(\n            engine=db.get_sqlalchemy_engine(), table_name=table_name\n        )\n        pretty = atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]Table[/b]: [i]{table_name}[/i]\")\n        result.append(pretty)\n\n    return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/","title":"table","text":""},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType","title":"<code>TableType</code>","text":"<p>         Bases: <code>AnyType[KiaraTable, DataTypeConfig]</code></p> <p>Tabular data (table, spreadsheet, data_frame, what have you).</p> <p>The table data is organized in sets of columns (arrays of data of the same type), with each column having a string identifier.</p> <p>kiara uses an instance of the <code>KiaraTable</code> class to manage the table data, which let's developers access it in different formats (Apache Arrow Table, Pandas dataframe, Python dict of lists, more to follow...).</p> <p>Please consult the API doc of the <code>KiaraTable</code> class for more information about how to access and query the data:</p> <ul> <li><code>KiaraTable</code> API doc</li> </ul> <p>Internally, the data is stored in Apache Feather format -- both in memory and on disk when saved, which enables some advanced usage to preserve memory and compute overhead.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>class TableType(AnyType[KiaraTable, DataTypeConfig]):\n\"\"\"Tabular data (table, spreadsheet, data_frame, what have you).\n\n    The table data is organized in sets of columns (arrays of data of the same type), with each column having a string identifier.\n\n    *kiara* uses an instance of the [`KiaraTable`][kiara_plugin.tabular.models.table.KiaraTable]\n    class to manage the table data, which let's developers access it in different formats ([Apache Arrow Table](https://arrow.apache.org/docs/python/generated/pyarrow.Table.html), [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html), Python dict of lists, more to follow...).\n\n    Please consult the API doc of the `KiaraTable` class for more information about how to access and query the data:\n\n    - [`KiaraTable` API doc](https://dharpa.org/kiara_plugin.tabular/latest/reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.table.KiaraTable)\n\n    Internally, the data is stored in [Apache Feather format](https://arrow.apache.org/docs/python/feather.html) -- both\n    in memory and on disk when saved, which enables some advanced usage to preserve memory and compute overhead.\n    \"\"\"\n\n    _data_type_name = \"table\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return KiaraTable\n\n    def parse_python_obj(self, data: Any) -&gt; KiaraTable:\n\n        return KiaraTable.create_table(data)\n\n    # def calculate_hash(self, data: KiaraTable) -&gt; CID:\n    #     hashes = []\n    #     for column_name in data.arrow_table.column_names:\n    #         hashes.append(column_name)\n    #         column = data.arrow_table.column(column_name)\n    #         for chunk in column.chunks:\n    #             for buf in chunk.buffers():\n    #                 if not buf:\n    #                     continue\n    #                 h = hash_from_buffer(memoryview(buf))\n    #                 hashes.append(h)\n    #     return compute_cid(hashes)\n    #     return KIARA_HASH_FUNCTION(memoryview(data.arrow_array))\n\n    # def calculate_size(self, data: KiaraTable) -&gt; int:\n    #     return len(data.arrow_table)\n\n    def _validate(cls, value: Any) -&gt; None:\n\n        pass\n\n        if not isinstance(value, KiaraTable):\n            raise Exception(\n                f\"invalid type '{type(value).__name__}', must be 'KiaraTable'.\"\n            )\n\n    def serialize(self, data: KiaraTable) -&gt; SerializedData:\n\n        import pyarrow as pa\n\n        chunk_map = {}\n\n        # TODO: make sure temp dir is in the same partition as file store\n        temp_f = tempfile.mkdtemp()\n\n        def cleanup():\n            shutil.rmtree(temp_f, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        for column_name in data.arrow_table.column_names:\n            column: pa.Array = data.arrow_table.column(column_name)\n            if not column_name:\n                file_name = os.path.join(temp_f, EMPTY_COLUMN_NAME_MARKER)\n            else:\n                file_name = os.path.join(temp_f, column_name)\n            store_array(array_obj=column, file_name=file_name, column_name=column_name)\n            chunk_map[column_name] = {\"type\": \"file\", \"file\": file_name, \"codec\": \"raw\"}\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": chunk_map,\n            \"serialization_profile\": \"feather\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"load.table\",\n                        \"module_config\": {\n                            \"value_type\": \"table\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"feather\",\n                        },\n                    }\n                },\n            },\n        }\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        atw = ArrowTabularWrap(value.data.arrow_table)\n        result = atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        return result\n\n    def pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        atw = ArrowTabularWrap(value.data.arrow_table)\n        result = atw.as_string(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return KiaraTable\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; KiaraTable</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; KiaraTable:\n\n    return KiaraTable.create_table(data)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType.serialize","title":"<code>serialize(data: KiaraTable) -&gt; SerializedData</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>def serialize(self, data: KiaraTable) -&gt; SerializedData:\n\n    import pyarrow as pa\n\n    chunk_map = {}\n\n    # TODO: make sure temp dir is in the same partition as file store\n    temp_f = tempfile.mkdtemp()\n\n    def cleanup():\n        shutil.rmtree(temp_f, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    for column_name in data.arrow_table.column_names:\n        column: pa.Array = data.arrow_table.column(column_name)\n        if not column_name:\n            file_name = os.path.join(temp_f, EMPTY_COLUMN_NAME_MARKER)\n        else:\n            file_name = os.path.join(temp_f, column_name)\n        store_array(array_obj=column, file_name=file_name, column_name=column_name)\n        chunk_map[column_name] = {\"type\": \"file\", \"file\": file_name, \"codec\": \"raw\"}\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": chunk_map,\n        \"serialization_profile\": \"feather\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"load.table\",\n                    \"module_config\": {\n                        \"value_type\": \"table\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"feather\",\n                    },\n                }\n            },\n        },\n    }\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    atw = ArrowTabularWrap(value.data.arrow_table)\n    result = atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table.TableType.pretty_print_as__string","title":"<code>pretty_print_as__string(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/data_types/table.py</code> <pre><code>def pretty_print_as__string(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    atw = ArrowTabularWrap(value.data.arrow_table)\n    result = atw.as_string(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/data_types/table/#kiara_plugin.tabular.data_types.table-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.tabular</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.ColumnSchema","title":"<code>ColumnSchema</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Describes properties of a single column of the 'table' data type.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/__init__.py</code> <pre><code>class ColumnSchema(BaseModel):\n\"\"\"Describes properties of a single column of the 'table' data type.\"\"\"\n\n    type_name: str = Field(\n        description=\"The type name of the column (backend-specific).\"\n    )\n    metadata: Dict[str, Any] = Field(\n        description=\"Other metadata for the column.\", default_factory=dict\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.ColumnSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.ColumnSchema.type_name","title":"<code>type_name: str = Field(description='The type name of the column (backend-specific).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.ColumnSchema.metadata","title":"<code>metadata: Dict[str, Any] = Field(description='Other metadata for the column.', default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata","title":"<code>TableMetadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Describes properties for the 'table' data type.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/__init__.py</code> <pre><code>class TableMetadata(KiaraModel):\n\"\"\"Describes properties for the 'table' data type.\"\"\"\n\n    column_names: List[str] = Field(description=\"The name of the columns of the table.\")\n    column_schema: Dict[str, ColumnSchema] = Field(\n        description=\"The schema description of the table.\"\n    )\n    rows: int = Field(description=\"The number of rows the table contains.\")\n    size: Union[int, None] = Field(\n        description=\"The tables size in bytes.\", default=None\n    )\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n\n        return {\n            \"column_schemas\": {k: v.dict() for k, v in self.column_schema.items()},\n            \"rows\": self.rows,\n            \"size\": self.size,\n        }\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata.column_names","title":"<code>column_names: List[str] = Field(description='The name of the columns of the table.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata.column_schema","title":"<code>column_schema: Dict[str, ColumnSchema] = Field(description='The schema description of the table.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata.rows","title":"<code>rows: int = Field(description='The number of rows the table contains.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/__init__/#kiara_plugin.tabular.models.TableMetadata.size","title":"<code>size: Union[int, None] = Field(description='The tables size in bytes.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/array/","title":"array","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray","title":"<code>KiaraArray</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A class to manage array-like data.</p> <p>Internally, this uses an Apache Arrow Array to handle the data in memory and on disk.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/array.py</code> <pre><code>class KiaraArray(KiaraModel):\n\"\"\"A class to manage array-like data.\n\n    Internally, this uses an [Apache Arrow Array](https://arrow.apache.org/docs/python/generated/pyarrow.Array.html#pyarrow.Array) to handle the data in memory and on disk.\n    \"\"\"\n\n    # @classmethod\n    # def create_in_temp_dir(cls, ):\n    #\n    #     temp_f = tempfile.mkdtemp()\n    #     file_path = os.path.join(temp_f, \"array.feather\")\n    #\n    #     def cleanup():\n    #         shutil.rmtree(file_path, ignore_errors=True)\n    #\n    #     atexit.register(cleanup)\n    #\n    #     array_obj = cls(feather_path=file_path)\n    #     return array_obj\n\n    @classmethod\n    def create_array(cls, data: Any) -&gt; \"KiaraArray\":\n\n        if isinstance(data, KiaraArray):\n            return data\n\n        array_obj = None\n        if isinstance(data, (pa.Array, pa.ChunkedArray)):\n            array_obj = data\n        elif isinstance(data, pa.Table):\n            if len(data.columns) != 1:\n                raise Exception(\n                    f\"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with {len(data.columns)} columns.\"\n                )\n            array_obj = data.column(0)\n        else:\n            try:\n                array_obj = pa.array(data)\n            except Exception:\n                pass\n\n        if array_obj is None:\n            raise Exception(\n                f\"Can't create table, invalid source data type: {type(data)}.\"\n            )\n\n        obj = KiaraArray()\n        if not isinstance(array_obj, pa.lib.ChunkedArray):\n            array_obj = pa.chunked_array(array_obj)\n        obj._array_obj = array_obj\n        return obj\n\n    data_path: Union[str, None] = Field(\n        description=\"The path to the (feather) file backing this array.\", default=None\n    )\n\n    _array_obj: pa.Array = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        raise NotImplementedError()\n\n    def __len__(self):\n        return len(self.arrow_array)\n\n    @property\n    def arrow_array(self) -&gt; pa.Array:\n\n        if self._array_obj is not None:\n            return self._array_obj\n\n        if not self.data_path:\n            raise Exception(\"Can't retrieve array data, object not initialized (yet).\")\n\n        with pa.memory_map(self.data_path, \"r\") as source:\n            table: pa.Table = pa.ipc.open_file(source).read_all()\n\n        if len(table.columns) != 1:\n            raise Exception(\n                f\"Invalid serialized array data, only a single-column Table is allowed. This value is a table with {len(table.columns)} columns.\"\n            )\n\n        self._array_obj = table.column(0)\n        return self._array_obj\n\n    def to_pylist(self):\n        return self.arrow_array.to_pylist()\n\n    def to_pandas(self):\n        return self.arrow_array.to_pandas()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray.data_path","title":"<code>data_path: Union[str, None] = Field(description='The path to the (feather) file backing this array.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray.arrow_array","title":"<code>arrow_array: pa.Array</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray.create_array","title":"<code>create_array(data: Any) -&gt; KiaraArray</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/array.py</code> <pre><code>@classmethod\ndef create_array(cls, data: Any) -&gt; \"KiaraArray\":\n\n    if isinstance(data, KiaraArray):\n        return data\n\n    array_obj = None\n    if isinstance(data, (pa.Array, pa.ChunkedArray)):\n        array_obj = data\n    elif isinstance(data, pa.Table):\n        if len(data.columns) != 1:\n            raise Exception(\n                f\"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with {len(data.columns)} columns.\"\n            )\n        array_obj = data.column(0)\n    else:\n        try:\n            array_obj = pa.array(data)\n        except Exception:\n            pass\n\n    if array_obj is None:\n        raise Exception(\n            f\"Can't create table, invalid source data type: {type(data)}.\"\n        )\n\n    obj = KiaraArray()\n    if not isinstance(array_obj, pa.lib.ChunkedArray):\n        array_obj = pa.chunked_array(array_obj)\n    obj._array_obj = array_obj\n    return obj\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray.to_pylist","title":"<code>to_pylist()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/array.py</code> <pre><code>def to_pylist(self):\n    return self.arrow_array.to_pylist()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/array/#kiara_plugin.tabular.models.array.KiaraArray.to_pandas","title":"<code>to_pandas()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/array.py</code> <pre><code>def to_pandas(self):\n    return self.arrow_array.to_pandas()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/","title":"db","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KDBC","title":"<code>KDBC = TypeVar('KDBC', bound='KiaraDatabase')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema","title":"<code>SqliteTableSchema</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>class SqliteTableSchema(BaseModel):\n\n    columns: Dict[str, SqliteDataType] = Field(\n        description=\"The table columns and their attributes.\"\n    )\n    index_columns: List[str] = Field(\n        description=\"The columns to index\", default_factory=list\n    )\n    nullable_columns: List[str] = Field(\n        description=\"The columns that are nullable.\", default_factory=list\n    )\n    unique_columns: List[str] = Field(\n        description=\"The columns that should be marked 'UNIQUE'.\", default_factory=list\n    )\n    primary_key: Union[str, None] = Field(\n        description=\"The primary key for this table.\", default=None\n    )\n\n    def create_table_metadata(\n        self,\n        table_name: str,\n    ) -&gt; Tuple[MetaData, Table]:\n\"\"\"Create an sql script to initialize a table.\n\n        Arguments:\n            column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values\n        \"\"\"\n\n        table_columns = []\n        for column_name, data_type in self.columns.items():\n            column_obj = Column(\n                column_name,\n                SQLITE_SQLALCHEMY_TYPE_MAP[data_type],\n                nullable=column_name in self.nullable_columns,\n                primary_key=column_name == self.primary_key,\n                index=column_name in self.index_columns,\n                unique=column_name in self.unique_columns,\n            )\n            table_columns.append(column_obj)\n\n        meta = MetaData()\n        table = Table(table_name, meta, *table_columns)\n        return meta, table\n\n    def create_table(self, table_name: str, engine: Engine) -&gt; Table:\n\n        meta, table = self.create_table_metadata(table_name=table_name)\n        meta.create_all(engine)\n        return table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.columns","title":"<code>columns: Dict[str, SqliteDataType] = Field(description='The table columns and their attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.index_columns","title":"<code>index_columns: List[str] = Field(description='The columns to index', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.nullable_columns","title":"<code>nullable_columns: List[str] = Field(description='The columns that are nullable.', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.unique_columns","title":"<code>unique_columns: List[str] = Field(description=\"The columns that should be marked 'UNIQUE'.\", default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.primary_key","title":"<code>primary_key: Union[str, None] = Field(description='The primary key for this table.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.create_table_metadata","title":"<code>create_table_metadata(table_name: str) -&gt; Tuple[MetaData, Table]</code>","text":"<p>Create an sql script to initialize a table.</p> <p>Parameters:</p> Name Type Description Default <code>column_attrs</code> <p>a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values</p> required Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def create_table_metadata(\n    self,\n    table_name: str,\n) -&gt; Tuple[MetaData, Table]:\n\"\"\"Create an sql script to initialize a table.\n\n    Arguments:\n        column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values\n    \"\"\"\n\n    table_columns = []\n    for column_name, data_type in self.columns.items():\n        column_obj = Column(\n            column_name,\n            SQLITE_SQLALCHEMY_TYPE_MAP[data_type],\n            nullable=column_name in self.nullable_columns,\n            primary_key=column_name == self.primary_key,\n            index=column_name in self.index_columns,\n            unique=column_name in self.unique_columns,\n        )\n        table_columns.append(column_obj)\n\n    meta = MetaData()\n    table = Table(table_name, meta, *table_columns)\n    return meta, table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.SqliteTableSchema.create_table","title":"<code>create_table(table_name: str, engine: Engine) -&gt; Table</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def create_table(self, table_name: str, engine: Engine) -&gt; Table:\n\n    meta, table = self.create_table_metadata(table_name=table_name)\n    meta.create_all(engine)\n    return table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase","title":"<code>KiaraDatabase</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A wrapper class to manage a sqlite database.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>class KiaraDatabase(KiaraModel):\n\"\"\"A wrapper class to manage a sqlite database.\"\"\"\n\n    @classmethod\n    def create_in_temp_dir(\n        cls: Type[KDBC],\n        init_statement: Union[None, str, \"TextClause\"] = None,\n        init_data: Union[Mapping[str, Any], None] = None,\n    ) -&gt; KDBC:\n\n        temp_f = tempfile.mkdtemp()\n        db_path = os.path.join(temp_f, \"db.sqlite\")\n\n        def cleanup():\n            shutil.rmtree(db_path, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        db = cls(db_file_path=db_path)\n        db.create_if_not_exists()\n\n        if init_statement:\n            db._unlock_db()\n            db.execute_sql(statement=init_statement, data=init_data, invalidate=True)\n            db._lock_db()\n\n        return db\n\n    db_file_path: str = Field(description=\"The path to the sqlite database file.\")\n\n    _cached_engine = PrivateAttr(default=None)\n    _cached_inspector = PrivateAttr(default=None)\n    _table_names = PrivateAttr(default=None)\n    _tables: Dict[str, Table] = PrivateAttr(default_factory=dict)\n    _metadata_obj: Union[MetaData, None] = PrivateAttr(default=None)\n    # _table_schemas: Optional[Dict[str, SqliteTableSchema]] = PrivateAttr(default=None)\n    # _file_hash: Optional[str] = PrivateAttr(default=None)\n    _file_cid: Union[CID, None] = PrivateAttr(default=None)\n    _lock: bool = PrivateAttr(default=True)\n    _immutable: bool = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.file_cid)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.file_cid\n\n    @validator(\"db_file_path\", allow_reuse=True)\n    def ensure_absolute_path(cls, path: str):\n\n        path = os.path.abspath(path)\n        if not os.path.exists(os.path.dirname(path)):\n            raise ValueError(f\"Parent folder for database file does not exist: {path}\")\n        return path\n\n    @property\n    def db_url(self) -&gt; str:\n        return f\"sqlite:///{self.db_file_path}\"\n\n    @property\n    def file_cid(self) -&gt; CID:\n\n        if self._file_cid is not None:\n            return self._file_cid\n\n        self._file_cid = compute_cid_from_file(file=self.db_file_path, codec=\"raw\")\n        return self._file_cid\n\n    def get_sqlalchemy_engine(self) -&gt; \"Engine\":\n\n        if self._cached_engine is not None:\n            return self._cached_engine\n\n        def _pragma_on_connect(dbapi_con, con_record):\n            dbapi_con.execute(\"PRAGMA query_only = ON\")\n\n        self._cached_engine = create_engine(self.db_url, future=True)\n\n        if self._lock:\n            event.listen(self._cached_engine, \"connect\", _pragma_on_connect)\n\n        return self._cached_engine\n\n    def _lock_db(self):\n        self._lock = True\n        self._invalidate()\n\n    def _unlock_db(self):\n        if self._immutable:\n            raise Exception(\"Can't unlock db, it's immutable.\")\n        self._lock = False\n        self._invalidate()\n\n    def create_if_not_exists(self):\n\n        from sqlalchemy_utils import create_database, database_exists\n\n        if not database_exists(self.db_url):\n            create_database(self.db_url)\n\n    def execute_sql(\n        self,\n        statement: Union[str, \"TextClause\"],\n        data: Union[Mapping[str, Any], None] = None,\n        invalidate: bool = False,\n    ):\n\"\"\"Execute an sql script.\n\n        Arguments:\n          statement: the sql statement\n          data: (optional) data, to be bound to the statement\n          invalidate: whether to invalidate cached values within this object\n        \"\"\"\n\n        if isinstance(statement, str):\n            statement = text(statement)\n\n        if data:\n            statement = statement.bindparams(**data)\n\n        with self.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(statement)\n\n        if invalidate:\n            self._invalidate()\n\n        return result\n\n    def _invalidate(self):\n        self._cached_engine = None\n        self._cached_inspector = None\n        self._table_names = None\n        # self._file_hash = None\n        self._metadata_obj = None\n        self._tables.clear()\n\n    def _invalidate_other(self):\n        pass\n\n    def get_sqlalchemy_metadata(self) -&gt; MetaData:\n\"\"\"Return the sqlalchemy Metadtaa object for the underlying database.\n\n        This is used internally, you typically don't need to access this attribute.\n\n        \"\"\"\n\n        if self._metadata_obj is None:\n            self._metadata_obj = MetaData()\n        return self._metadata_obj\n\n    def copy_database_file(self, target: str):\n\n        os.makedirs(os.path.dirname(target))\n\n        shutil.copy2(self.db_file_path, target)\n\n        new_db = KiaraDatabase(db_file_path=target)\n        # if self._file_hash:\n        #     new_db._file_hash = self._file_hash\n        return new_db\n\n    def get_sqlalchemy_inspector(self) -&gt; Inspector:\n\n        if self._cached_inspector is not None:\n            return self._cached_inspector\n\n        self._cached_inspector = inspect(self.get_sqlalchemy_engine())\n        return self._cached_inspector\n\n    @property\n    def table_names(self) -&gt; Iterable[str]:\n        if self._table_names is not None:\n            return self._table_names\n\n        self._table_names = self.get_sqlalchemy_inspector().get_table_names()\n        return self._table_names\n\n    def get_sqlalchemy_table(self, table_name: str) -&gt; Table:\n\"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\"\n\n        if table_name in self._tables.keys():\n            return self._tables[table_name]\n\n        table = Table(\n            table_name,\n            self.get_sqlalchemy_metadata(),\n            autoload_with=self.get_sqlalchemy_engine(),\n        )\n        self._tables[table_name] = table\n        return table\n\n    def get_table_as_pandas_df(self, table_name: str) -&gt; \"pd.DataFrame\":\n\n        import pandas as pd\n\n        query = text(f'SELECT * FROM \"{table_name}\"')\n        with self.get_sqlalchemy_engine().connect() as con:\n            df = pd.read_sql(query, con)  # noqa\n\n        return df\n\n    def create_metadata(self) -&gt; \"DatabaseMetadata\":\n\n        insp = self.get_sqlalchemy_inspector()\n\n        mds = {}\n\n        for table_name in insp.get_table_names():\n\n            with self.get_sqlalchemy_engine().connect() as con:\n                query = f'SELECT count(*) from \"{table_name}\"'\n                result = con.execute(text(query))\n                num_rows = result.fetchone()[0]\n\n                try:\n                    result = con.execute(\n                        text(\n                            f'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\"{table_name}\"'\n                        )\n                    )\n                    size: Union[int, None] = result.fetchone()[0]\n                except Exception:\n                    size = None\n\n            columns = {}\n            for column in insp.get_columns(table_name=table_name):\n                name = column[\"name\"]\n                _type = column[\"type\"]\n                type_name = SQLALCHEMY_SQLITE_TYPE_MAP[type(_type)]\n                columns[name] = {\n                    \"type_name\": type_name,\n                    \"metadata\": {\n                        \"nullable\": column[\"nullable\"],\n                        \"primary_key\": True if column[\"primary_key\"] else False,\n                    },\n                }\n\n            schema = {\n                \"column_names\": list(columns.keys()),\n                \"column_schema\": columns,\n                \"rows\": num_rows,\n                \"size\": size,\n            }\n\n            md = TableMetadata(**schema)\n            mds[table_name] = md\n\n        return DatabaseMetadata.construct(tables=mds)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.db_file_path","title":"<code>db_file_path: str = Field(description='The path to the sqlite database file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.file_cid","title":"<code>file_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.table_names","title":"<code>table_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.create_in_temp_dir","title":"<code>create_in_temp_dir(init_statement: Union[None, str, TextClause] = None, init_data: Union[Mapping[str, Any], None] = None) -&gt; KDBC</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>@classmethod\ndef create_in_temp_dir(\n    cls: Type[KDBC],\n    init_statement: Union[None, str, \"TextClause\"] = None,\n    init_data: Union[Mapping[str, Any], None] = None,\n) -&gt; KDBC:\n\n    temp_f = tempfile.mkdtemp()\n    db_path = os.path.join(temp_f, \"db.sqlite\")\n\n    def cleanup():\n        shutil.rmtree(db_path, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    db = cls(db_file_path=db_path)\n    db.create_if_not_exists()\n\n    if init_statement:\n        db._unlock_db()\n        db.execute_sql(statement=init_statement, data=init_data, invalidate=True)\n        db._lock_db()\n\n    return db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.ensure_absolute_path","title":"<code>ensure_absolute_path(path: str)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>@validator(\"db_file_path\", allow_reuse=True)\ndef ensure_absolute_path(cls, path: str):\n\n    path = os.path.abspath(path)\n    if not os.path.exists(os.path.dirname(path)):\n        raise ValueError(f\"Parent folder for database file does not exist: {path}\")\n    return path\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.get_sqlalchemy_engine","title":"<code>get_sqlalchemy_engine() -&gt; Engine</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def get_sqlalchemy_engine(self) -&gt; \"Engine\":\n\n    if self._cached_engine is not None:\n        return self._cached_engine\n\n    def _pragma_on_connect(dbapi_con, con_record):\n        dbapi_con.execute(\"PRAGMA query_only = ON\")\n\n    self._cached_engine = create_engine(self.db_url, future=True)\n\n    if self._lock:\n        event.listen(self._cached_engine, \"connect\", _pragma_on_connect)\n\n    return self._cached_engine\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.create_if_not_exists","title":"<code>create_if_not_exists()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def create_if_not_exists(self):\n\n    from sqlalchemy_utils import create_database, database_exists\n\n    if not database_exists(self.db_url):\n        create_database(self.db_url)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.execute_sql","title":"<code>execute_sql(statement: Union[str, TextClause], data: Union[Mapping[str, Any], None] = None, invalidate: bool = False)</code>","text":"<p>Execute an sql script.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Union[str, TextClause]</code> <p>the sql statement</p> required <code>data</code> <code>Union[Mapping[str, Any], None]</code> <p>(optional) data, to be bound to the statement</p> <code>None</code> <code>invalidate</code> <code>bool</code> <p>whether to invalidate cached values within this object</p> <code>False</code> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def execute_sql(\n    self,\n    statement: Union[str, \"TextClause\"],\n    data: Union[Mapping[str, Any], None] = None,\n    invalidate: bool = False,\n):\n\"\"\"Execute an sql script.\n\n    Arguments:\n      statement: the sql statement\n      data: (optional) data, to be bound to the statement\n      invalidate: whether to invalidate cached values within this object\n    \"\"\"\n\n    if isinstance(statement, str):\n        statement = text(statement)\n\n    if data:\n        statement = statement.bindparams(**data)\n\n    with self.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(statement)\n\n    if invalidate:\n        self._invalidate()\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.get_sqlalchemy_metadata","title":"<code>get_sqlalchemy_metadata() -&gt; MetaData</code>","text":"<p>Return the sqlalchemy Metadtaa object for the underlying database.</p> <p>This is used internally, you typically don't need to access this attribute.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def get_sqlalchemy_metadata(self) -&gt; MetaData:\n\"\"\"Return the sqlalchemy Metadtaa object for the underlying database.\n\n    This is used internally, you typically don't need to access this attribute.\n\n    \"\"\"\n\n    if self._metadata_obj is None:\n        self._metadata_obj = MetaData()\n    return self._metadata_obj\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.copy_database_file","title":"<code>copy_database_file(target: str)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def copy_database_file(self, target: str):\n\n    os.makedirs(os.path.dirname(target))\n\n    shutil.copy2(self.db_file_path, target)\n\n    new_db = KiaraDatabase(db_file_path=target)\n    # if self._file_hash:\n    #     new_db._file_hash = self._file_hash\n    return new_db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.get_sqlalchemy_inspector","title":"<code>get_sqlalchemy_inspector() -&gt; Inspector</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def get_sqlalchemy_inspector(self) -&gt; Inspector:\n\n    if self._cached_inspector is not None:\n        return self._cached_inspector\n\n    self._cached_inspector = inspect(self.get_sqlalchemy_engine())\n    return self._cached_inspector\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.get_sqlalchemy_table","title":"<code>get_sqlalchemy_table(table_name: str) -&gt; Table</code>","text":"<p>Return the sqlalchemy edges table instance for this network datab.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def get_sqlalchemy_table(self, table_name: str) -&gt; Table:\n\"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\"\n\n    if table_name in self._tables.keys():\n        return self._tables[table_name]\n\n    table = Table(\n        table_name,\n        self.get_sqlalchemy_metadata(),\n        autoload_with=self.get_sqlalchemy_engine(),\n    )\n    self._tables[table_name] = table\n    return table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.get_table_as_pandas_df","title":"<code>get_table_as_pandas_df(table_name: str) -&gt; pd.DataFrame</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def get_table_as_pandas_df(self, table_name: str) -&gt; \"pd.DataFrame\":\n\n    import pandas as pd\n\n    query = text(f'SELECT * FROM \"{table_name}\"')\n    with self.get_sqlalchemy_engine().connect() as con:\n        df = pd.read_sql(query, con)  # noqa\n\n    return df\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.KiaraDatabase.create_metadata","title":"<code>create_metadata() -&gt; DatabaseMetadata</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>def create_metadata(self) -&gt; \"DatabaseMetadata\":\n\n    insp = self.get_sqlalchemy_inspector()\n\n    mds = {}\n\n    for table_name in insp.get_table_names():\n\n        with self.get_sqlalchemy_engine().connect() as con:\n            query = f'SELECT count(*) from \"{table_name}\"'\n            result = con.execute(text(query))\n            num_rows = result.fetchone()[0]\n\n            try:\n                result = con.execute(\n                    text(\n                        f'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\"{table_name}\"'\n                    )\n                )\n                size: Union[int, None] = result.fetchone()[0]\n            except Exception:\n                size = None\n\n        columns = {}\n        for column in insp.get_columns(table_name=table_name):\n            name = column[\"name\"]\n            _type = column[\"type\"]\n            type_name = SQLALCHEMY_SQLITE_TYPE_MAP[type(_type)]\n            columns[name] = {\n                \"type_name\": type_name,\n                \"metadata\": {\n                    \"nullable\": column[\"nullable\"],\n                    \"primary_key\": True if column[\"primary_key\"] else False,\n                },\n            }\n\n        schema = {\n            \"column_names\": list(columns.keys()),\n            \"column_schema\": columns,\n            \"rows\": num_rows,\n            \"size\": size,\n        }\n\n        md = TableMetadata(**schema)\n        mds[table_name] = md\n\n    return DatabaseMetadata.construct(tables=mds)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata","title":"<code>DatabaseMetadata</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>Database and table properties.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>class DatabaseMetadata(ValueMetadata):\n\"\"\"Database and table properties.\"\"\"\n\n    _metadata_key = \"database\"\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"database\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: Value) -&gt; \"DatabaseMetadata\":\n\n        database: KiaraDatabase = value.data\n        return database.create_metadata()\n\n    tables: Dict[str, TableMetadata] = Field(description=\"The table schema.\")\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata.tables","title":"<code>tables: Dict[str, TableMetadata] = Field(description='The table schema.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"database\"]\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/db/#kiara_plugin.tabular.models.db.DatabaseMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; DatabaseMetadata</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/db.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: Value) -&gt; \"DatabaseMetadata\":\n\n    database: KiaraDatabase = value.data\n    return database.create_metadata()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/","title":"table","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable","title":"<code>KiaraTable</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A wrapper class to manage tabular data in a memory efficient way.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>class KiaraTable(KiaraModel):\n\"\"\"A wrapper class to manage tabular data in a memory efficient way.\"\"\"\n\n    @classmethod\n    def create_table(cls, data: Any) -&gt; \"KiaraTable\":\n\"\"\"Create a `KiaraTable` instance from an Apache Arrow Table, or dict of lists.\"\"\"\n\n        table_obj = None\n        if isinstance(data, KiaraTable):\n            return data\n\n        if isinstance(data, (pa.Table)):\n            table_obj = data\n        else:\n            try:\n                table_obj = pa.table(data)\n            except Exception:\n                pass\n\n        if table_obj is None:\n            raise Exception(\n                f\"Can't create table, invalid source data type: {type(data)}.\"\n            )\n\n        obj = KiaraTable()\n        obj._table_obj = table_obj\n        return obj\n\n    data_path: Union[None, str] = Field(\n        description=\"The path to the (feather) file backing this array.\", default=None\n    )\n\"\"\"The path where the table object is store (for internal or read-only use).\"\"\"\n    _table_obj: pa.Table = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        raise NotImplementedError()\n\n    @property\n    def arrow_table(self) -&gt; pa.Table:\n\"\"\"Return the data as an Apache Arrow Table instance.\"\"\"\n\n        if self._table_obj is not None:\n            return self._table_obj\n\n        if not self.data_path:\n            raise Exception(\"Can't retrieve table data, object not initialized (yet).\")\n\n        with pa.memory_map(self.data_path, \"r\") as source:\n            table: pa.Table = pa.ipc.open_file(source).read_all()\n\n        self._table_obj = table\n        return self._table_obj\n\n    @property\n    def polars_dataframe(self) -&gt; \"pl.DataFrame\":\n\"\"\"Return the data as a Polars dataframe.\"\"\"\n\n        import polars as pl\n\n        return pl.from_arrow(self.arrow_table)  # type: ignore\n\n    @property\n    def column_names(self) -&gt; Iterable[str]:\n\"\"\"Retrieve the names of all the columns of this table.\"\"\"\n        return self.arrow_table.column_names\n\n    @property\n    def num_rows(self) -&gt; int:\n\"\"\"Return the number of rows in this table.\"\"\"\n        return self.arrow_table.num_rows\n\n    def to_pydict(self):\n\"\"\"Convert and return the table data as a dictionary of lists.\n\n        This will load all data into memory, so you might or might not want to do that.\n        \"\"\"\n        return self.arrow_table.to_pydict()\n\n    def to_pylist(self):\n\"\"\"Convert and return the table data as a list of rows/dictionaries.\n\n        This will load all data into memory, so you might or might not want to do that.\n        \"\"\"\n\n        return self.arrow_table.to_pylist()\n\n    def to_pandas(self):\n\"\"\"Convert and return the table data to a Pandas dataframe.\n\n        This will load all data into memory, so you might or might not want to do that.\n        \"\"\"\n        return self.arrow_table.to_pandas()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.data_path","title":"<code>data_path: Union[None, str] = Field(description='The path to the (feather) file backing this array.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path where the table object is store (for internal or read-only use).</p>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.arrow_table","title":"<code>arrow_table: pa.Table</code>  <code>property</code>","text":"<p>Return the data as an Apache Arrow Table instance.</p>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.polars_dataframe","title":"<code>polars_dataframe: pl.DataFrame</code>  <code>property</code>","text":"<p>Return the data as a Polars dataframe.</p>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.column_names","title":"<code>column_names: Iterable[str]</code>  <code>property</code>","text":"<p>Retrieve the names of all the columns of this table.</p>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.num_rows","title":"<code>num_rows: int</code>  <code>property</code>","text":"<p>Return the number of rows in this table.</p>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.create_table","title":"<code>create_table(data: Any) -&gt; KiaraTable</code>  <code>classmethod</code>","text":"<p>Create a <code>KiaraTable</code> instance from an Apache Arrow Table, or dict of lists.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>@classmethod\ndef create_table(cls, data: Any) -&gt; \"KiaraTable\":\n\"\"\"Create a `KiaraTable` instance from an Apache Arrow Table, or dict of lists.\"\"\"\n\n    table_obj = None\n    if isinstance(data, KiaraTable):\n        return data\n\n    if isinstance(data, (pa.Table)):\n        table_obj = data\n    else:\n        try:\n            table_obj = pa.table(data)\n        except Exception:\n            pass\n\n    if table_obj is None:\n        raise Exception(\n            f\"Can't create table, invalid source data type: {type(data)}.\"\n        )\n\n    obj = KiaraTable()\n    obj._table_obj = table_obj\n    return obj\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.to_pydict","title":"<code>to_pydict()</code>","text":"<p>Convert and return the table data as a dictionary of lists.</p> <p>This will load all data into memory, so you might or might not want to do that.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>def to_pydict(self):\n\"\"\"Convert and return the table data as a dictionary of lists.\n\n    This will load all data into memory, so you might or might not want to do that.\n    \"\"\"\n    return self.arrow_table.to_pydict()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.to_pylist","title":"<code>to_pylist()</code>","text":"<p>Convert and return the table data as a list of rows/dictionaries.</p> <p>This will load all data into memory, so you might or might not want to do that.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>def to_pylist(self):\n\"\"\"Convert and return the table data as a list of rows/dictionaries.\n\n    This will load all data into memory, so you might or might not want to do that.\n    \"\"\"\n\n    return self.arrow_table.to_pylist()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTable.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Convert and return the table data to a Pandas dataframe.</p> <p>This will load all data into memory, so you might or might not want to do that.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>def to_pandas(self):\n\"\"\"Convert and return the table data to a Pandas dataframe.\n\n    This will load all data into memory, so you might or might not want to do that.\n    \"\"\"\n    return self.arrow_table.to_pandas()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata","title":"<code>KiaraTableMetadata</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>File stats.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>class KiaraTableMetadata(ValueMetadata):\n\"\"\"File stats.\"\"\"\n\n    _metadata_key = \"table\"\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"table\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: \"Value\") -&gt; \"KiaraTableMetadata\":\n\n        kiara_table: KiaraTable = value.data\n\n        table: pa.Table = kiara_table.arrow_table\n\n        table_schema = {}\n        for name in table.schema.names:\n            field = table.schema.field(name)\n            md = field.metadata\n            _type = field.type\n            if not md:\n                md = {\n                    \"arrow_type_id\": _type.id,\n                }\n            _d = {\n                \"type_name\": str(_type),\n                \"metadata\": md,\n            }\n            table_schema[name] = _d\n\n        schema = {\n            \"column_names\": table.column_names,\n            \"column_schema\": table_schema,\n            \"rows\": table.num_rows,\n            \"size\": table.nbytes,\n        }\n\n        md = TableMetadata.construct(**schema)\n        return KiaraTableMetadata.construct(table=md)\n\n    table: TableMetadata = Field(description=\"The table schema.\")\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata.table","title":"<code>table: TableMetadata = Field(description='The table schema.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"table\"]\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/models/table/#kiara_plugin.tabular.models.table.KiaraTableMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; KiaraTableMetadata</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/models/table.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: \"Value\") -&gt; \"KiaraTableMetadata\":\n\n    kiara_table: KiaraTable = value.data\n\n    table: pa.Table = kiara_table.arrow_table\n\n    table_schema = {}\n    for name in table.schema.names:\n        field = table.schema.field(name)\n        md = field.metadata\n        _type = field.type\n        if not md:\n            md = {\n                \"arrow_type_id\": _type.id,\n            }\n        _d = {\n            \"type_name\": str(_type),\n            \"metadata\": md,\n        }\n        table_schema[name] = _d\n\n    schema = {\n        \"column_names\": table.column_names,\n        \"column_schema\": table_schema,\n        \"rows\": table.num_rows,\n        \"size\": table.nbytes,\n    }\n\n    md = TableMetadata.construct(**schema)\n    return KiaraTableMetadata.construct(table=md)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/","title":"array","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.FORCE_NON_NULL_DOC","title":"<code>FORCE_NON_NULL_DOC = \"If set to 'True', raise an error if any of the strings in the array can't be parsed.\"</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.MIN_INDEX_DOC","title":"<code>MIN_INDEX_DOC = 'The minimum index from where to start parsing the string(s).'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.MAX_INDEX_DOC","title":"<code>MAX_INDEX_DOC = 'The maximum index until whic to parse the string(s).'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.REMOVE_TOKENS_DOC","title":"<code>REMOVE_TOKENS_DOC = 'A list of tokens/characters to replace with a single white-space before parsing the input.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule","title":"<code>DeserializeArrayModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> <p>Deserialize array data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>class DeserializeArrayModule(DeserializeValueModule):\n\"\"\"Deserialize array data.\"\"\"\n\n    _module_type_name = \"load.array\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": KiaraArray}\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"array\"\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"feather\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        assert \"array.arrow\" in data.get_keys() and len(list(data.get_keys())) == 1\n\n        chunks = data.get_serialized_data(\"array.arrow\")\n\n        # TODO: support multiple chunks\n        assert chunks.get_number_of_chunks() == 1\n        files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n        assert len(files) == 1\n\n        array_file = files[0]\n\n        array = KiaraArray(data_path=array_file)\n        return array\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": KiaraArray}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"array\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"feather\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.DeserializeArrayModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    assert \"array.arrow\" in data.get_keys() and len(list(data.get_keys())) == 1\n\n    chunks = data.get_serialized_data(\"array.arrow\")\n\n    # TODO: support multiple chunks\n    assert chunks.get_number_of_chunks() == 1\n    files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n    assert len(files) == 1\n\n    array_file = files[0]\n\n    array = KiaraArray(data_path=array_file)\n    return array\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig","title":"<code>ExtractDateConfig</code>","text":"<p>         Bases: <code>KiaraInputsConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>class ExtractDateConfig(KiaraInputsConfig):\n\n    force_non_null: bool = Field(description=FORCE_NON_NULL_DOC, default=True)\n    min_index: Union[None, int] = Field(\n        description=MIN_INDEX_DOC,\n        default=None,\n    )\n    max_index: Union[None, int] = Field(description=MAX_INDEX_DOC, default=None)\n    remove_tokens: List[str] = Field(\n        description=REMOVE_TOKENS_DOC, default_factory=list\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig.force_non_null","title":"<code>force_non_null: bool = Field(description=FORCE_NON_NULL_DOC, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig.min_index","title":"<code>min_index: Union[None, int] = Field(description=MIN_INDEX_DOC, default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig.max_index","title":"<code>max_index: Union[None, int] = Field(description=MAX_INDEX_DOC, default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateConfig.remove_tokens","title":"<code>remove_tokens: List[str] = Field(description=REMOVE_TOKENS_DOC, default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule","title":"<code>ExtractDateModule</code>","text":"<p>         Bases: <code>AutoInputsKiaraModule</code></p> <p>Create an array of date objects from an array of strings.</p> <p>This module is very simplistic at the moment, more functionality and options will be added in the future.</p> <p>At its core, this module uses the standard parser from the dateutil package to parse strings into dates. As this parser can't handle  complex strings, the input strings can be pre-processed in the following ways:</p> <ul> <li>'cut' non-relevant parts of the string (using 'min_index' &amp; 'max_index' input/config options)</li> <li>remove matching tokens from the string, and replace them with a single whitespace (using the 'remove_tokens' option)</li> </ul> <p>By default, if an input string can't be parsed this module will raise an exception. This can be prevented by setting this modules 'force_non_null' config option or input to 'False', in which case un-parsable strings will appear as 'NULL' value in the resulting array.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>class ExtractDateModule(AutoInputsKiaraModule):\n\"\"\"Create an array of date objects from an array of strings.\n\n    This module is very simplistic at the moment, more functionality and options will be added in the future.\n\n    At its core, this module uses the standard parser from the\n    [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. As this parser can't handle\n     complex strings, the input strings can be pre-processed in the following ways:\n\n    - 'cut' non-relevant parts of the string (using 'min_index' &amp; 'max_index' input/config options)\n    - remove matching tokens from the string, and replace them with a single whitespace (using the 'remove_tokens' option)\n\n    By default, if an input string can't be parsed this module will raise an exception. This can be prevented by\n    setting this modules 'force_non_null' config option or input to 'False', in which case un-parsable strings\n    will appear as 'NULL' value in the resulting array.\n    \"\"\"\n\n    _module_type_name = \"parse.date_array\"\n    _config_cls = ExtractDateConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        inputs = {\"array\": {\"type\": \"array\", \"doc\": \"The input array.\"}}\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"date_array\": {\n                \"type\": \"array\",\n                \"doc\": \"The resulting array with items of a date data type.\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog):\n\n        import polars as pl\n        import pyarrow as pa\n        from dateutil import parser\n\n        force_non_null: bool = self.get_data_for_field(\n            field_name=\"force_non_null\", inputs=inputs\n        )\n        min_pos: Union[None, int] = self.get_data_for_field(\n            field_name=\"min_index\", inputs=inputs\n        )\n        if min_pos is None:\n            min_pos = 0\n        max_pos: Union[None, int] = self.get_data_for_field(\n            field_name=\"max_index\", inputs=inputs\n        )\n        remove_tokens: Iterable[str] = self.get_data_for_field(\n            field_name=\"remove_tokens\", inputs=inputs\n        )\n\n        def parse_date(_text: str):\n\n            text = _text\n            if min_pos:\n                try:\n                    text = text[min_pos:]  # type: ignore\n                except Exception:\n                    return None\n            if max_pos:\n                try:\n                    text = text[0 : max_pos - min_pos]  # type: ignore\n                except Exception:\n                    pass\n\n            if remove_tokens:\n                for t in remove_tokens:\n                    text = text.replace(t, \" \")\n\n            try:\n                d_obj = parser.parse(text, fuzzy=True)\n            except Exception as e:\n                if force_non_null:\n                    raise KiaraProcessingException(e)\n                return None\n\n            if d_obj is None:\n                if force_non_null:\n                    raise KiaraProcessingException(\n                        f\"Can't parse date from string: {text}\"\n                    )\n                return None\n\n            return d_obj\n\n        value = inputs.get_value_obj(\"array\")\n        array: KiaraArray = value.data\n\n        series = pl.Series(name=\"tokens\", values=array.arrow_array)\n        job_log.add_log(f\"start parsing date for {len(array)} items\")\n        result = series.apply(parse_date)\n        job_log.add_log(f\"finished parsing date for {len(array)} items\")\n        result_array = result.to_arrow()\n\n        # TODO: remove this cast once the array data type can handle non-chunked arrays\n        chunked = pa.chunked_array(result_array)\n        outputs.set_values(date_array=chunked)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule._config_cls","title":"<code>_config_cls = ExtractDateConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    inputs = {\"array\": {\"type\": \"array\", \"doc\": \"The input array.\"}}\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"date_array\": {\n            \"type\": \"array\",\n            \"doc\": \"The resulting array with items of a date data type.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/array/__init__/#kiara_plugin.tabular.modules.array.ExtractDateModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap, job_log: JobLog)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/array/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog):\n\n    import polars as pl\n    import pyarrow as pa\n    from dateutil import parser\n\n    force_non_null: bool = self.get_data_for_field(\n        field_name=\"force_non_null\", inputs=inputs\n    )\n    min_pos: Union[None, int] = self.get_data_for_field(\n        field_name=\"min_index\", inputs=inputs\n    )\n    if min_pos is None:\n        min_pos = 0\n    max_pos: Union[None, int] = self.get_data_for_field(\n        field_name=\"max_index\", inputs=inputs\n    )\n    remove_tokens: Iterable[str] = self.get_data_for_field(\n        field_name=\"remove_tokens\", inputs=inputs\n    )\n\n    def parse_date(_text: str):\n\n        text = _text\n        if min_pos:\n            try:\n                text = text[min_pos:]  # type: ignore\n            except Exception:\n                return None\n        if max_pos:\n            try:\n                text = text[0 : max_pos - min_pos]  # type: ignore\n            except Exception:\n                pass\n\n        if remove_tokens:\n            for t in remove_tokens:\n                text = text.replace(t, \" \")\n\n        try:\n            d_obj = parser.parse(text, fuzzy=True)\n        except Exception as e:\n            if force_non_null:\n                raise KiaraProcessingException(e)\n            return None\n\n        if d_obj is None:\n            if force_non_null:\n                raise KiaraProcessingException(\n                    f\"Can't parse date from string: {text}\"\n                )\n            return None\n\n        return d_obj\n\n    value = inputs.get_value_obj(\"array\")\n    array: KiaraArray = value.data\n\n    series = pl.Series(name=\"tokens\", values=array.arrow_array)\n    job_log.add_log(f\"start parsing date for {len(array)} items\")\n    result = series.apply(parse_date)\n    job_log.add_log(f\"finished parsing date for {len(array)} items\")\n    result_array = result.to_arrow()\n\n    # TODO: remove this cast once the array data type can handle non-chunked arrays\n    chunked = pa.chunked_array(result_array)\n    outputs.set_values(date_array=chunked)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/","title":"db","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig","title":"<code>CreateDatabaseModuleConfig</code>","text":"<p>         Bases: <code>CreateFromModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class CreateDatabaseModuleConfig(CreateFromModuleConfig):\n\n    ignore_errors: bool = Field(\n        description=\"Whether to ignore convert errors and omit the failed items.\",\n        default=False,\n    )\n    merge_into_single_table: bool = Field(\n        description=\"Whether to merge all csv files into a single table.\", default=False\n    )\n    include_source_metadata: Union[bool, None] = Field(\n        description=\"Whether to include a table with metadata about the source files.\",\n        default=None,\n    )\n    include_source_file_content: bool = Field(\n        description=\"When including source metadata, whether to also include the original raw (string) content.\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig.ignore_errors","title":"<code>ignore_errors: bool = Field(description='Whether to ignore convert errors and omit the failed items.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig.merge_into_single_table","title":"<code>merge_into_single_table: bool = Field(description='Whether to merge all csv files into a single table.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig.include_source_metadata","title":"<code>include_source_metadata: Union[bool, None] = Field(description='Whether to include a table with metadata about the source files.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModuleConfig.include_source_file_content","title":"<code>include_source_file_content: bool = Field(description='When including source metadata, whether to also include the original raw (string) content.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule","title":"<code>CreateDatabaseModule</code>","text":"<p>         Bases: <code>CreateFromModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class CreateDatabaseModule(CreateFromModule):\n\n    _module_type_name = \"create.database\"\n    _config_cls = CreateDatabaseModuleConfig\n\n    def create__database__from__file(\n        self, source_value: Value, optional: ValueMap\n    ) -&gt; Any:\n\"\"\"Create a database from a file.\n\n        Currently, only csv files are supported.\n        \"\"\"\n        import csv as py_csv\n\n        temp_f = tempfile.mkdtemp()\n        db_path = os.path.join(temp_f, \"db.sqlite\")\n\n        def cleanup():\n            shutil.rmtree(db_path, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        file_item: FileModel = source_value.data\n        if not file_item.file_name.endswith(\".csv\"):\n            raise KiaraProcessingException(\n                \"Only csv files are supported (at the moment).\"\n            )\n\n        table_name = file_item.file_name_without_extension\n\n        table_name = table_name.replace(\"-\", \"_\")\n        table_name = table_name.replace(\".\", \"_\")\n\n        has_header = optional.get_value_data(\"first_row_is_header\")\n        if has_header is None:\n            try:\n                has_header = True\n                with open(source_value.data.path, \"rt\") as csvfile:\n                    sniffer = py_csv.Sniffer()\n                    has_header = sniffer.has_header(csvfile.read(2048))\n                    csvfile.seek(0)\n            except Exception as e:\n                # TODO: add this to the procss log\n                log_message(\n                    \"csv_sniffer.error\",\n                    file=source_value.data.path,\n                    error=str(e),\n                    details=\"assuming csv file has header\",\n                )\n\n        try:\n            create_sqlite_table_from_tabular_file(\n                target_db_file=db_path,\n                file_item=file_item,\n                table_name=table_name,\n                no_headers=not has_header,\n            )\n        except Exception as e:\n            if self.get_config_value(\"ignore_errors\") is True or True:\n                log_message(\"ignore.import_file\", file=file_item.path, reason=str(e))\n            else:\n                raise KiaraProcessingException(e)\n\n        include_raw_content_in_file_info: bool = self.get_config_value(\n            \"include_source_metadata\"\n        )\n        if include_raw_content_in_file_info:\n            db = KiaraDatabase(db_file_path=db_path)\n            db.create_if_not_exists()\n            include_content: bool = self.get_config_value(\"include_source_file_content\")\n            db._unlock_db()\n            included_files = {file_item.file_name: file_item}\n            file_bundle = FileBundle.create_from_file_models(\n                files=included_files, bundle_name=file_item.file_name\n            )\n            insert_db_table_from_file_bundle(\n                database=db,\n                file_bundle=file_bundle,\n                table_name=\"source_files_metadata\",\n                include_content=include_content,\n            )\n            db._lock_db()\n\n        return db_path\n\n    def create__database__from__file_bundle(\n        self, source_value: Value, job_log: JobLog\n    ) -&gt; Any:\n\"\"\"Create a database from a file_bundle value.\n\n        Currently, only csv files are supported, files in the source file_bundle that have different extensions will be ignored.\n\n        Unless 'merge_into_single_table' is set to 'True' in the module configuration, each csv file will create one table\n        in the resulting database. If this option is set, only a single table with all the values of all\n        csv files will be created. For this to work, all csv files should follow the same schema.\n\n        \"\"\"\n\n        merge_into_single_table = self.get_config_value(\"merge_into_single_table\")\n        if merge_into_single_table:\n            raise NotImplementedError(\"Not supported (yet).\")\n\n        include_raw_content_in_file_info: Union[bool, None] = self.get_config_value(\n            \"include_source_metadata\"\n        )\n\n        temp_f = tempfile.mkdtemp()\n        db_path = os.path.join(temp_f, \"db.sqlite\")\n\n        def cleanup():\n            shutil.rmtree(db_path, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        db = KiaraDatabase(db_file_path=db_path)\n        db.create_if_not_exists()\n\n        # TODO: check whether/how to add indexes\n\n        bundle: FileBundle = source_value.data\n\n        table_names: List[str] = []\n        included_files: Dict[str, bool] = {}\n        errors: Dict[str, Union[None, str]] = {}\n        for rel_path in sorted(bundle.included_files.keys()):\n\n            if not rel_path.endswith(\".csv\"):\n                job_log.add_log(\n                    f\"Ignoring file (not csv): {rel_path}\", log_level=logging.INFO\n                )\n                included_files[rel_path] = False\n                errors[rel_path] = \"Not a csv file.\"\n                continue\n\n            file_item = bundle.included_files[rel_path]\n            table_name = find_free_id(\n                stem=file_item.file_name_without_extension, current_ids=table_names\n            )\n            try:\n                table_names.append(table_name)\n                create_sqlite_table_from_tabular_file(\n                    target_db_file=db_path, file_item=file_item, table_name=table_name\n                )\n                included_files[rel_path] = True\n            except Exception as e:\n                included_files[rel_path] = False\n                errors[rel_path] = KiaraException.get_root_details(e)\n\n                if self.get_config_value(\"ignore_errors\") is True or True:\n                    log_message(\"ignore.import_file\", file=rel_path, reason=str(e))\n                    continue\n\n                raise KiaraProcessingException(e)\n\n        if include_raw_content_in_file_info in [None, True]:\n            include_content: bool = self.get_config_value(\"include_source_file_content\")\n            db._unlock_db()\n\n            insert_db_table_from_file_bundle(\n                database=db,\n                file_bundle=source_value.data,\n                table_name=\"source_files_metadata\",\n                include_content=include_content,\n                included_files=included_files,\n                errors=errors,\n            )\n            db._lock_db()\n\n        return db_path\n\n    def create_optional_inputs(\n        self, source_type: str, target_type\n    ) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n\n        inputs = {}\n        if source_type == \"file\":\n            inputs[\"first_row_is_header\"] = {\n                \"type\": \"boolean\",\n                \"optional\": True,\n                \"doc\": \"Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine.\",\n            }\n\n        if target_type == \"database\" and source_type == \"table\":\n\n            inputs[\"table_name\"] = {\n                \"type\": \"string\",\n                \"doc\": \"The name of the table in the new database.\",\n                \"default\": \"imported_table\",\n            }\n\n        return inputs\n\n    def create__database__from__table(\n        self, source_value: Value, optional: ValueMap\n    ) -&gt; Any:\n\"\"\"Create a database value from a table.\"\"\"\n\n        table_name = optional.get_value_data(\"table_name\")\n        if not table_name:\n            table_name = \"imported_table\"\n\n        table: KiaraTable = source_value.data\n        arrow_table = table.arrow_table\n\n        column_map = None\n        index_columns = None\n\n        sqlite_schema = create_sqlite_schema_data_from_arrow_table(\n            table=arrow_table, index_columns=index_columns, column_map=column_map\n        )\n\n        db = KiaraDatabase.create_in_temp_dir()\n        db._unlock_db()\n        engine = db.get_sqlalchemy_engine()\n\n        _table = sqlite_schema.create_table(table_name=table_name, engine=engine)\n\n        with engine.connect() as conn:\n\n            for batch in arrow_table.to_batches(\n                max_chunksize=DEFAULT_TABULAR_DATA_CHUNK_SIZE\n            ):\n                conn.execute(insert(_table), batch.to_pylist())\n                conn.commit()\n\n        db._lock_db()\n        return db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule._config_cls","title":"<code>_config_cls = CreateDatabaseModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule.create__database__from__file","title":"<code>create__database__from__file(source_value: Value, optional: ValueMap) -&gt; Any</code>","text":"<p>Create a database from a file.</p> <p>Currently, only csv files are supported.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create__database__from__file(\n    self, source_value: Value, optional: ValueMap\n) -&gt; Any:\n\"\"\"Create a database from a file.\n\n    Currently, only csv files are supported.\n    \"\"\"\n    import csv as py_csv\n\n    temp_f = tempfile.mkdtemp()\n    db_path = os.path.join(temp_f, \"db.sqlite\")\n\n    def cleanup():\n        shutil.rmtree(db_path, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    file_item: FileModel = source_value.data\n    if not file_item.file_name.endswith(\".csv\"):\n        raise KiaraProcessingException(\n            \"Only csv files are supported (at the moment).\"\n        )\n\n    table_name = file_item.file_name_without_extension\n\n    table_name = table_name.replace(\"-\", \"_\")\n    table_name = table_name.replace(\".\", \"_\")\n\n    has_header = optional.get_value_data(\"first_row_is_header\")\n    if has_header is None:\n        try:\n            has_header = True\n            with open(source_value.data.path, \"rt\") as csvfile:\n                sniffer = py_csv.Sniffer()\n                has_header = sniffer.has_header(csvfile.read(2048))\n                csvfile.seek(0)\n        except Exception as e:\n            # TODO: add this to the procss log\n            log_message(\n                \"csv_sniffer.error\",\n                file=source_value.data.path,\n                error=str(e),\n                details=\"assuming csv file has header\",\n            )\n\n    try:\n        create_sqlite_table_from_tabular_file(\n            target_db_file=db_path,\n            file_item=file_item,\n            table_name=table_name,\n            no_headers=not has_header,\n        )\n    except Exception as e:\n        if self.get_config_value(\"ignore_errors\") is True or True:\n            log_message(\"ignore.import_file\", file=file_item.path, reason=str(e))\n        else:\n            raise KiaraProcessingException(e)\n\n    include_raw_content_in_file_info: bool = self.get_config_value(\n        \"include_source_metadata\"\n    )\n    if include_raw_content_in_file_info:\n        db = KiaraDatabase(db_file_path=db_path)\n        db.create_if_not_exists()\n        include_content: bool = self.get_config_value(\"include_source_file_content\")\n        db._unlock_db()\n        included_files = {file_item.file_name: file_item}\n        file_bundle = FileBundle.create_from_file_models(\n            files=included_files, bundle_name=file_item.file_name\n        )\n        insert_db_table_from_file_bundle(\n            database=db,\n            file_bundle=file_bundle,\n            table_name=\"source_files_metadata\",\n            include_content=include_content,\n        )\n        db._lock_db()\n\n    return db_path\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule.create__database__from__file_bundle","title":"<code>create__database__from__file_bundle(source_value: Value, job_log: JobLog) -&gt; Any</code>","text":"<p>Create a database from a file_bundle value.</p> <p>Currently, only csv files are supported, files in the source file_bundle that have different extensions will be ignored.</p> <p>Unless 'merge_into_single_table' is set to 'True' in the module configuration, each csv file will create one table in the resulting database. If this option is set, only a single table with all the values of all csv files will be created. For this to work, all csv files should follow the same schema.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create__database__from__file_bundle(\n    self, source_value: Value, job_log: JobLog\n) -&gt; Any:\n\"\"\"Create a database from a file_bundle value.\n\n    Currently, only csv files are supported, files in the source file_bundle that have different extensions will be ignored.\n\n    Unless 'merge_into_single_table' is set to 'True' in the module configuration, each csv file will create one table\n    in the resulting database. If this option is set, only a single table with all the values of all\n    csv files will be created. For this to work, all csv files should follow the same schema.\n\n    \"\"\"\n\n    merge_into_single_table = self.get_config_value(\"merge_into_single_table\")\n    if merge_into_single_table:\n        raise NotImplementedError(\"Not supported (yet).\")\n\n    include_raw_content_in_file_info: Union[bool, None] = self.get_config_value(\n        \"include_source_metadata\"\n    )\n\n    temp_f = tempfile.mkdtemp()\n    db_path = os.path.join(temp_f, \"db.sqlite\")\n\n    def cleanup():\n        shutil.rmtree(db_path, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    db = KiaraDatabase(db_file_path=db_path)\n    db.create_if_not_exists()\n\n    # TODO: check whether/how to add indexes\n\n    bundle: FileBundle = source_value.data\n\n    table_names: List[str] = []\n    included_files: Dict[str, bool] = {}\n    errors: Dict[str, Union[None, str]] = {}\n    for rel_path in sorted(bundle.included_files.keys()):\n\n        if not rel_path.endswith(\".csv\"):\n            job_log.add_log(\n                f\"Ignoring file (not csv): {rel_path}\", log_level=logging.INFO\n            )\n            included_files[rel_path] = False\n            errors[rel_path] = \"Not a csv file.\"\n            continue\n\n        file_item = bundle.included_files[rel_path]\n        table_name = find_free_id(\n            stem=file_item.file_name_without_extension, current_ids=table_names\n        )\n        try:\n            table_names.append(table_name)\n            create_sqlite_table_from_tabular_file(\n                target_db_file=db_path, file_item=file_item, table_name=table_name\n            )\n            included_files[rel_path] = True\n        except Exception as e:\n            included_files[rel_path] = False\n            errors[rel_path] = KiaraException.get_root_details(e)\n\n            if self.get_config_value(\"ignore_errors\") is True or True:\n                log_message(\"ignore.import_file\", file=rel_path, reason=str(e))\n                continue\n\n            raise KiaraProcessingException(e)\n\n    if include_raw_content_in_file_info in [None, True]:\n        include_content: bool = self.get_config_value(\"include_source_file_content\")\n        db._unlock_db()\n\n        insert_db_table_from_file_bundle(\n            database=db,\n            file_bundle=source_value.data,\n            table_name=\"source_files_metadata\",\n            include_content=include_content,\n            included_files=included_files,\n            errors=errors,\n        )\n        db._lock_db()\n\n    return db_path\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule.create_optional_inputs","title":"<code>create_optional_inputs(source_type: str, target_type: str) -&gt; Union[Mapping[str, Mapping[str, Any]], None]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create_optional_inputs(\n    self, source_type: str, target_type\n) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n\n    inputs = {}\n    if source_type == \"file\":\n        inputs[\"first_row_is_header\"] = {\n            \"type\": \"boolean\",\n            \"optional\": True,\n            \"doc\": \"Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine.\",\n        }\n\n    if target_type == \"database\" and source_type == \"table\":\n\n        inputs[\"table_name\"] = {\n            \"type\": \"string\",\n            \"doc\": \"The name of the table in the new database.\",\n            \"default\": \"imported_table\",\n        }\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.CreateDatabaseModule.create__database__from__table","title":"<code>create__database__from__table(source_value: Value, optional: ValueMap) -&gt; Any</code>","text":"<p>Create a database value from a table.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create__database__from__table(\n    self, source_value: Value, optional: ValueMap\n) -&gt; Any:\n\"\"\"Create a database value from a table.\"\"\"\n\n    table_name = optional.get_value_data(\"table_name\")\n    if not table_name:\n        table_name = \"imported_table\"\n\n    table: KiaraTable = source_value.data\n    arrow_table = table.arrow_table\n\n    column_map = None\n    index_columns = None\n\n    sqlite_schema = create_sqlite_schema_data_from_arrow_table(\n        table=arrow_table, index_columns=index_columns, column_map=column_map\n    )\n\n    db = KiaraDatabase.create_in_temp_dir()\n    db._unlock_db()\n    engine = db.get_sqlalchemy_engine()\n\n    _table = sqlite_schema.create_table(table_name=table_name, engine=engine)\n\n    with engine.connect() as conn:\n\n        for batch in arrow_table.to_batches(\n            max_chunksize=DEFAULT_TABULAR_DATA_CHUNK_SIZE\n        ):\n            conn.execute(insert(_table), batch.to_pylist())\n            conn.commit()\n\n    db._lock_db()\n    return db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule","title":"<code>LoadDatabaseFromDiskModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class LoadDatabaseFromDiskModule(DeserializeValueModule):\n\n    _module_type_name = \"load.database\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": KiaraDatabase}\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"database\"\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"copy\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        assert \"db.sqlite\" in data.get_keys() and len(list(data.get_keys())) == 1\n\n        chunks = data.get_serialized_data(\"db.sqlite\")\n\n        # TODO: support multiple chunks\n        assert chunks.get_number_of_chunks() == 1\n        files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n        assert len(files) == 1\n\n        db_file = files[0]\n\n        db = KiaraDatabase(db_file_path=db_file)\n        return db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": KiaraDatabase}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"database\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"copy\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.LoadDatabaseFromDiskModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    assert \"db.sqlite\" in data.get_keys() and len(list(data.get_keys())) == 1\n\n    chunks = data.get_serialized_data(\"db.sqlite\")\n\n    # TODO: support multiple chunks\n    assert chunks.get_number_of_chunks() == 1\n    files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n    assert len(files) == 1\n\n    db_file = files[0]\n\n    db = KiaraDatabase(db_file_path=db_file)\n    return db\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseConfig","title":"<code>QueryDatabaseConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class QueryDatabaseConfig(KiaraModuleConfig):\n\n    query: Union[str, None] = Field(description=\"The query.\", default=None)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseConfig.query","title":"<code>query: Union[str, None] = Field(description='The query.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule","title":"<code>QueryDatabaseModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Execute a sql query against a (sqlite) database.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class QueryDatabaseModule(KiaraModule):\n\"\"\"Execute a sql query against a (sqlite) database.\"\"\"\n\n    _config_cls = QueryDatabaseConfig\n    _module_type_name = \"query.database\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result: Dict[str, Dict[str, Any]] = {\n            \"database\": {\"type\": \"database\", \"doc\": \"The database to query.\"}\n        }\n\n        if not self.get_config_value(\"query\"):\n            result[\"query\"] = {\"type\": \"string\", \"doc\": \"The query to execute.\"}\n\n        return result\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\"query_result\": {\"type\": \"table\", \"doc\": \"The query result.\"}}\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        import pyarrow as pa\n\n        database: KiaraDatabase = inputs.get_value_data(\"database\")\n        query = self.get_config_value(\"query\")\n        if query is None:\n            query = inputs.get_value_data(\"query\")\n\n        # TODO: make this memory efficent\n\n        result_columns: Dict[str, List[Any]] = {}\n        with database.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(text(query))\n            for r in result:\n                for k, v in dict(r).items():\n                    result_columns.setdefault(k, []).append(v)\n\n        table = pa.Table.from_pydict(result_columns)\n        outputs.set_value(\"query_result\", table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule._config_cls","title":"<code>_config_cls = QueryDatabaseConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result: Dict[str, Dict[str, Any]] = {\n        \"database\": {\"type\": \"database\", \"doc\": \"The database to query.\"}\n    }\n\n    if not self.get_config_value(\"query\"):\n        result[\"query\"] = {\"type\": \"string\", \"doc\": \"The query to execute.\"}\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\"query_result\": {\"type\": \"table\", \"doc\": \"The query result.\"}}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.QueryDatabaseModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    import pyarrow as pa\n\n    database: KiaraDatabase = inputs.get_value_data(\"database\")\n    query = self.get_config_value(\"query\")\n    if query is None:\n        query = inputs.get_value_data(\"query\")\n\n    # TODO: make this memory efficent\n\n    result_columns: Dict[str, List[Any]] = {}\n    with database.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(text(query))\n        for r in result:\n            for k, v in dict(r).items():\n                result_columns.setdefault(k, []).append(v)\n\n    table = pa.Table.from_pydict(result_columns)\n    outputs.set_value(\"query_result\", table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModuleBase","title":"<code>RenderDatabaseModuleBase</code>","text":"<p>         Bases: <code>RenderValueModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class RenderDatabaseModuleBase(RenderValueModule):\n\n    _module_type_name: str = None  # type: ignore\n\n    def preprocess_database(\n        self,\n        value: Value,\n        table_name: Union[str, None],\n        input_number_of_rows: int,\n        input_row_offset: int,\n    ):\n\n        database: KiaraDatabase = value.data\n        table_names = database.table_names\n\n        if not table_name:\n            table_name = list(table_names)[0]\n\n        if table_name not in table_names:\n            raise Exception(\n                f\"Invalid table name: {table_name}. Available: {', '.join(table_names)}\"\n            )\n\n        related_scenes_tables: Dict[str, Union[RenderScene, None]] = {\n            t: RenderScene.construct(\n                title=t,\n                description=f\"Display the '{t}' table.\",\n                manifest_hash=self.manifest.manifest_hash,\n                render_config={\"table_name\": t},\n            )\n            for t in database.table_names\n        }\n\n        query = f\"\"\"SELECT * FROM {table_name} LIMIT {input_number_of_rows} OFFSET {input_row_offset}\"\"\"\n        result: Dict[str, List[Any]] = {}\n        # TODO: this could be written much more efficient\n        with database.get_sqlalchemy_engine().connect() as con:\n            num_rows_result = con.execute(text(f\"SELECT count(*) from {table_name}\"))\n            table_num_rows = num_rows_result.fetchone()[0]\n            rs = con.execute(text(query))\n            for r in rs:\n                for k, v in dict(r).items():\n                    result.setdefault(k, []).append(v)\n\n        wrap = DictTabularWrap(data=result)\n\n        row_offset = table_num_rows - input_number_of_rows\n        related_scenes: Dict[str, Union[RenderScene, None]] = {}\n        if row_offset &gt; 0:\n\n            if input_row_offset &gt; 0:\n                related_scenes[\"first\"] = RenderScene.construct(\n                    title=\"first\",\n                    description=f\"Display the first {input_number_of_rows} rows of this table.\",\n                    manifest_hash=self.manifest.manifest_hash,\n                    render_config={\n                        \"row_offset\": 0,\n                        \"number_of_rows\": input_number_of_rows,\n                        \"table_name\": table_name,\n                    },\n                )\n\n                p_offset = input_row_offset - input_number_of_rows\n                if p_offset &lt; 0:\n                    p_offset = 0\n                previous = {\n                    \"row_offset\": p_offset,\n                    \"number_of_rows\": input_number_of_rows,\n                    \"table_name\": table_name,\n                }\n                related_scenes[\"previous\"] = RenderScene.construct(title=\"previous\", description=f\"Display the previous {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=previous)  # type: ignore\n            else:\n                related_scenes[\"first\"] = None\n                related_scenes[\"previous\"] = None\n\n            n_offset = input_row_offset + input_number_of_rows\n            if n_offset &lt; table_num_rows:\n                next = {\n                    \"row_offset\": n_offset,\n                    \"number_of_rows\": input_number_of_rows,\n                    \"table_name\": table_name,\n                }\n                related_scenes[\"next\"] = RenderScene.construct(title=\"next\", description=f\"Display the next {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=next)  # type: ignore\n            else:\n                related_scenes[\"next\"] = None\n\n            last_page = int(table_num_rows / input_number_of_rows)\n            current_start = last_page * input_number_of_rows\n            if (input_row_offset + input_number_of_rows) &gt; table_num_rows:\n                related_scenes[\"last\"] = None\n            else:\n                related_scenes[\"last\"] = RenderScene.construct(\n                    title=\"last\",\n                    description=\"Display the final rows of this table.\",\n                    manifest_hash=self.manifest.manifest_hash,\n                    render_config={\n                        \"row_offset\": current_start,  # type: ignore\n                        \"number_of_rows\": input_number_of_rows,  # type: ignore\n                        \"table_name\": table_name,\n                    },\n                )\n        related_scenes_tables[table_name].disabled = True  # type: ignore\n        related_scenes_tables[table_name].related_scenes = related_scenes  # type: ignore\n        return wrap, related_scenes_tables\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModuleBase-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModuleBase.preprocess_database","title":"<code>preprocess_database(value: Value, table_name: Union[str, None], input_number_of_rows: int, input_row_offset: int)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def preprocess_database(\n    self,\n    value: Value,\n    table_name: Union[str, None],\n    input_number_of_rows: int,\n    input_row_offset: int,\n):\n\n    database: KiaraDatabase = value.data\n    table_names = database.table_names\n\n    if not table_name:\n        table_name = list(table_names)[0]\n\n    if table_name not in table_names:\n        raise Exception(\n            f\"Invalid table name: {table_name}. Available: {', '.join(table_names)}\"\n        )\n\n    related_scenes_tables: Dict[str, Union[RenderScene, None]] = {\n        t: RenderScene.construct(\n            title=t,\n            description=f\"Display the '{t}' table.\",\n            manifest_hash=self.manifest.manifest_hash,\n            render_config={\"table_name\": t},\n        )\n        for t in database.table_names\n    }\n\n    query = f\"\"\"SELECT * FROM {table_name} LIMIT {input_number_of_rows} OFFSET {input_row_offset}\"\"\"\n    result: Dict[str, List[Any]] = {}\n    # TODO: this could be written much more efficient\n    with database.get_sqlalchemy_engine().connect() as con:\n        num_rows_result = con.execute(text(f\"SELECT count(*) from {table_name}\"))\n        table_num_rows = num_rows_result.fetchone()[0]\n        rs = con.execute(text(query))\n        for r in rs:\n            for k, v in dict(r).items():\n                result.setdefault(k, []).append(v)\n\n    wrap = DictTabularWrap(data=result)\n\n    row_offset = table_num_rows - input_number_of_rows\n    related_scenes: Dict[str, Union[RenderScene, None]] = {}\n    if row_offset &gt; 0:\n\n        if input_row_offset &gt; 0:\n            related_scenes[\"first\"] = RenderScene.construct(\n                title=\"first\",\n                description=f\"Display the first {input_number_of_rows} rows of this table.\",\n                manifest_hash=self.manifest.manifest_hash,\n                render_config={\n                    \"row_offset\": 0,\n                    \"number_of_rows\": input_number_of_rows,\n                    \"table_name\": table_name,\n                },\n            )\n\n            p_offset = input_row_offset - input_number_of_rows\n            if p_offset &lt; 0:\n                p_offset = 0\n            previous = {\n                \"row_offset\": p_offset,\n                \"number_of_rows\": input_number_of_rows,\n                \"table_name\": table_name,\n            }\n            related_scenes[\"previous\"] = RenderScene.construct(title=\"previous\", description=f\"Display the previous {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=previous)  # type: ignore\n        else:\n            related_scenes[\"first\"] = None\n            related_scenes[\"previous\"] = None\n\n        n_offset = input_row_offset + input_number_of_rows\n        if n_offset &lt; table_num_rows:\n            next = {\n                \"row_offset\": n_offset,\n                \"number_of_rows\": input_number_of_rows,\n                \"table_name\": table_name,\n            }\n            related_scenes[\"next\"] = RenderScene.construct(title=\"next\", description=f\"Display the next {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=next)  # type: ignore\n        else:\n            related_scenes[\"next\"] = None\n\n        last_page = int(table_num_rows / input_number_of_rows)\n        current_start = last_page * input_number_of_rows\n        if (input_row_offset + input_number_of_rows) &gt; table_num_rows:\n            related_scenes[\"last\"] = None\n        else:\n            related_scenes[\"last\"] = RenderScene.construct(\n                title=\"last\",\n                description=\"Display the final rows of this table.\",\n                manifest_hash=self.manifest.manifest_hash,\n                render_config={\n                    \"row_offset\": current_start,  # type: ignore\n                    \"number_of_rows\": input_number_of_rows,  # type: ignore\n                    \"table_name\": table_name,\n                },\n            )\n    related_scenes_tables[table_name].disabled = True  # type: ignore\n    related_scenes_tables[table_name].related_scenes = related_scenes  # type: ignore\n    return wrap, related_scenes_tables\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModule","title":"<code>RenderDatabaseModule</code>","text":"<p>         Bases: <code>RenderDatabaseModuleBase</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>class RenderDatabaseModule(RenderDatabaseModuleBase):\n    _module_type_name = \"render.database\"\n\n    def render__database__as__string(\n        self, value: Value, render_config: Mapping[str, Any]\n    ):\n\n        input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n        input_row_offset = render_config.get(\"row_offset\", 0)\n\n        table_name = render_config.get(\"table_name\", None)\n\n        wrap, data_related_scenes = self.preprocess_database(\n            value=value,\n            table_name=table_name,\n            input_number_of_rows=input_number_of_rows,\n            input_row_offset=input_row_offset,\n        )\n        pretty = wrap.as_string(max_row_height=1)\n\n        return RenderValueResult(\n            value_id=value.value_id,\n            rendered=pretty,\n            related_scenes=data_related_scenes,\n            render_config=render_config,\n            render_manifest=self.manifest.manifest_hash,\n        )\n\n    def render__database__as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ):\n\n        input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n        input_row_offset = render_config.get(\"row_offset\", 0)\n\n        table_name = render_config.get(\"table_name\", None)\n\n        wrap, data_related_scenes = self.preprocess_database(\n            value=value,\n            table_name=table_name,\n            input_number_of_rows=input_number_of_rows,\n            input_row_offset=input_row_offset,\n        )\n        pretty = wrap.as_terminal_renderable(max_row_height=1)\n\n        return RenderValueResult(\n            value_id=value.value_id,\n            render_config=render_config,\n            rendered=pretty,\n            related_scenes=data_related_scenes,\n            render_manifest=self.manifest.manifest_hash,\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModule.render__database__as__string","title":"<code>render__database__as__string(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def render__database__as__string(\n    self, value: Value, render_config: Mapping[str, Any]\n):\n\n    input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n    input_row_offset = render_config.get(\"row_offset\", 0)\n\n    table_name = render_config.get(\"table_name\", None)\n\n    wrap, data_related_scenes = self.preprocess_database(\n        value=value,\n        table_name=table_name,\n        input_number_of_rows=input_number_of_rows,\n        input_row_offset=input_row_offset,\n    )\n    pretty = wrap.as_string(max_row_height=1)\n\n    return RenderValueResult(\n        value_id=value.value_id,\n        rendered=pretty,\n        related_scenes=data_related_scenes,\n        render_config=render_config,\n        render_manifest=self.manifest.manifest_hash,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db.RenderDatabaseModule.render__database__as__terminal_renderable","title":"<code>render__database__as__terminal_renderable(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/db/__init__.py</code> <pre><code>def render__database__as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n):\n\n    input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n    input_row_offset = render_config.get(\"row_offset\", 0)\n\n    table_name = render_config.get(\"table_name\", None)\n\n    wrap, data_related_scenes = self.preprocess_database(\n        value=value,\n        table_name=table_name,\n        input_number_of_rows=input_number_of_rows,\n        input_row_offset=input_row_offset,\n    )\n    pretty = wrap.as_terminal_renderable(max_row_height=1)\n\n    return RenderValueResult(\n        value_id=value.value_id,\n        render_config=render_config,\n        rendered=pretty,\n        related_scenes=data_related_scenes,\n        render_manifest=self.manifest.manifest_hash,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/db/__init__/#kiara_plugin.tabular.modules.db-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/","title":"table","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.EMPTY_COLUMN_NAME_MARKER","title":"<code>EMPTY_COLUMN_NAME_MARKER = '__no_column_name__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModuleConfig","title":"<code>CreateTableModuleConfig</code>","text":"<p>         Bases: <code>CreateFromModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class CreateTableModuleConfig(CreateFromModuleConfig):\n\n    ignore_errors: bool = Field(\n        description=\"Whether to ignore convert errors and omit the failed items.\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModuleConfig.ignore_errors","title":"<code>ignore_errors: bool = Field(description='Whether to ignore convert errors and omit the failed items.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule","title":"<code>CreateTableModule</code>","text":"<p>         Bases: <code>CreateFromModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class CreateTableModule(CreateFromModule):\n\n    _module_type_name = \"create.table\"\n    _config_cls = CreateTableModuleConfig\n\n    def create_optional_inputs(\n        self, source_type: str, target_type\n    ) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n\n        if source_type == \"file\":\n            return {\n                \"first_row_is_header\": {\n                    \"type\": \"boolean\",\n                    \"optional\": True,\n                    \"doc\": \"Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine.\",\n                }\n            }\n\n        return None\n\n    def create__table__from__file(self, source_value: Value, optional: ValueMap) -&gt; Any:\n\"\"\"Create a table from a file, trying to auto-determine the format of said file.\"\"\"\n\n        import csv as py_csv\n\n        from pyarrow import csv\n\n        input_file: FileModel = source_value.data\n        imported_data = None\n        errors = []\n\n        has_header = optional.get_value_data(\"first_row_is_header\")\n        if has_header is None:\n            try:\n                has_header = True\n                with open(input_file.path, \"rt\") as csvfile:\n                    sniffer = py_csv.Sniffer()\n                    has_header = sniffer.has_header(csvfile.read(2048))\n                    csvfile.seek(0)\n            except Exception as e:\n                # TODO: add this to the procss log\n                log_message(\n                    \"csv_sniffer.error\",\n                    file=input_file.path,\n                    error=str(e),\n                    details=\"assuming csv file has header\",\n                )\n\n        try:\n            if has_header:\n                imported_data = csv.read_csv(input_file.path)\n            else:\n                read_options = csv.ReadOptions(autogenerate_column_names=True)\n                imported_data = csv.read_csv(input_file.path, read_options=read_options)\n        except Exception as e:\n            errors.append(e)\n\n        if imported_data is None:\n            raise KiaraProcessingException(\n                f\"Failed to import file '{input_file.path}'.\"\n            )\n\n        # import pandas as pd\n        # df = pd.read_csv(input_file.path)\n        # imported_data = pa.Table.from_pandas(df)\n\n        return KiaraTable.create_table(imported_data)\n\n    # def create__table__from__csv_file(self, source_value: Value) -&gt; Any:\n    #     \"\"\"Create a table from a csv_file value.\"\"\"\n    #\n    #     from pyarrow import csv\n    #\n    #     input_file: FileModel = source_value.data\n    #     imported_data = csv.read_csv(input_file.path)\n    #\n    #     # import pandas as pd\n    #     # df = pd.read_csv(input_file.path)\n    #     # imported_data = pa.Table.from_pandas(df)\n    #\n    #     return KiaraTable.create_table(imported_data)\n\n    def create__table__from__file_bundle(self, source_value: Value) -&gt; Any:\n\"\"\"Create a table value from a text file_bundle.\n\n        The resulting table will have (at a minimum) the following collumns:\n        - id: an auto-assigned index\n        - rel_path: the relative path of the file (from the provided base path)\n        - content: the text file content\n        \"\"\"\n\n        import pyarrow as pa\n\n        bundle: FileBundle = source_value.data\n\n        columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS\n\n        ignore_errors = self.get_config_value(\"ignore_errors\")\n        file_dict = bundle.read_text_file_contents(ignore_errors=ignore_errors)\n\n        # TODO: use chunks to save on memory\n        tabular: Dict[str, List[Any]] = {}\n        for column in columns:\n            for index, rel_path in enumerate(sorted(file_dict.keys())):\n\n                if column == \"content\":\n                    _value: Any = file_dict[rel_path]\n                elif column == \"id\":\n                    _value = index\n                elif column == \"rel_path\":\n                    _value = rel_path\n                else:\n                    file_model = bundle.included_files[rel_path]\n                    _value = getattr(file_model, column)\n\n                tabular.setdefault(column, []).append(_value)\n\n        table = pa.Table.from_pydict(tabular)\n        return KiaraTable.create_table(table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule._config_cls","title":"<code>_config_cls = CreateTableModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule.create_optional_inputs","title":"<code>create_optional_inputs(source_type: str, target_type: str) -&gt; Union[Mapping[str, Mapping[str, Any]], None]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_optional_inputs(\n    self, source_type: str, target_type\n) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n\n    if source_type == \"file\":\n        return {\n            \"first_row_is_header\": {\n                \"type\": \"boolean\",\n                \"optional\": True,\n                \"doc\": \"Whether the first row of the file is a header row. If not provided, kiara will try to auto-determine.\",\n            }\n        }\n\n    return None\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule.create__table__from__file","title":"<code>create__table__from__file(source_value: Value, optional: ValueMap) -&gt; Any</code>","text":"<p>Create a table from a file, trying to auto-determine the format of said file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create__table__from__file(self, source_value: Value, optional: ValueMap) -&gt; Any:\n\"\"\"Create a table from a file, trying to auto-determine the format of said file.\"\"\"\n\n    import csv as py_csv\n\n    from pyarrow import csv\n\n    input_file: FileModel = source_value.data\n    imported_data = None\n    errors = []\n\n    has_header = optional.get_value_data(\"first_row_is_header\")\n    if has_header is None:\n        try:\n            has_header = True\n            with open(input_file.path, \"rt\") as csvfile:\n                sniffer = py_csv.Sniffer()\n                has_header = sniffer.has_header(csvfile.read(2048))\n                csvfile.seek(0)\n        except Exception as e:\n            # TODO: add this to the procss log\n            log_message(\n                \"csv_sniffer.error\",\n                file=input_file.path,\n                error=str(e),\n                details=\"assuming csv file has header\",\n            )\n\n    try:\n        if has_header:\n            imported_data = csv.read_csv(input_file.path)\n        else:\n            read_options = csv.ReadOptions(autogenerate_column_names=True)\n            imported_data = csv.read_csv(input_file.path, read_options=read_options)\n    except Exception as e:\n        errors.append(e)\n\n    if imported_data is None:\n        raise KiaraProcessingException(\n            f\"Failed to import file '{input_file.path}'.\"\n        )\n\n    # import pandas as pd\n    # df = pd.read_csv(input_file.path)\n    # imported_data = pa.Table.from_pandas(df)\n\n    return KiaraTable.create_table(imported_data)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.CreateTableModule.create__table__from__file_bundle","title":"<code>create__table__from__file_bundle(source_value: Value) -&gt; Any</code>","text":"<p>Create a table value from a text file_bundle.</p> <p>The resulting table will have (at a minimum) the following collumns: - id: an auto-assigned index - rel_path: the relative path of the file (from the provided base path) - content: the text file content</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create__table__from__file_bundle(self, source_value: Value) -&gt; Any:\n\"\"\"Create a table value from a text file_bundle.\n\n    The resulting table will have (at a minimum) the following collumns:\n    - id: an auto-assigned index\n    - rel_path: the relative path of the file (from the provided base path)\n    - content: the text file content\n    \"\"\"\n\n    import pyarrow as pa\n\n    bundle: FileBundle = source_value.data\n\n    columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS\n\n    ignore_errors = self.get_config_value(\"ignore_errors\")\n    file_dict = bundle.read_text_file_contents(ignore_errors=ignore_errors)\n\n    # TODO: use chunks to save on memory\n    tabular: Dict[str, List[Any]] = {}\n    for column in columns:\n        for index, rel_path in enumerate(sorted(file_dict.keys())):\n\n            if column == \"content\":\n                _value: Any = file_dict[rel_path]\n            elif column == \"id\":\n                _value = index\n            elif column == \"rel_path\":\n                _value = rel_path\n            else:\n                file_model = bundle.included_files[rel_path]\n                _value = getattr(file_model, column)\n\n            tabular.setdefault(column, []).append(_value)\n\n    table = pa.Table.from_pydict(tabular)\n    return KiaraTable.create_table(table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule","title":"<code>DeserializeTableModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class DeserializeTableModule(DeserializeValueModule):\n\n    _module_type_name = \"load.table\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": KiaraTable}\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"table\"\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"feather\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        import pyarrow as pa\n\n        columns = {}\n\n        for column_name in data.get_keys():\n\n            chunks = data.get_serialized_data(column_name)\n\n            # TODO: support multiple chunks\n            assert chunks.get_number_of_chunks() == 1\n            files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n            assert len(files) == 1\n\n            file = files[0]\n            with pa.memory_map(file, \"r\") as column_chunk:\n                loaded_arrays: pa.Table = pa.ipc.open_file(column_chunk).read_all()\n                column = loaded_arrays.column(column_name)\n                if column_name == EMPTY_COLUMN_NAME_MARKER:\n                    columns[\"\"] = column\n                else:\n                    columns[column_name] = column\n\n        arrow_table = pa.table(columns)\n\n        table = KiaraTable.create_table(arrow_table)\n        return table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": KiaraTable}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"table\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"feather\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.DeserializeTableModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    import pyarrow as pa\n\n    columns = {}\n\n    for column_name in data.get_keys():\n\n        chunks = data.get_serialized_data(column_name)\n\n        # TODO: support multiple chunks\n        assert chunks.get_number_of_chunks() == 1\n        files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n        assert len(files) == 1\n\n        file = files[0]\n        with pa.memory_map(file, \"r\") as column_chunk:\n            loaded_arrays: pa.Table = pa.ipc.open_file(column_chunk).read_all()\n            column = loaded_arrays.column(column_name)\n            if column_name == EMPTY_COLUMN_NAME_MARKER:\n                columns[\"\"] = column\n            else:\n                columns[column_name] = column\n\n    arrow_table = pa.table(columns)\n\n    table = KiaraTable.create_table(arrow_table)\n    return table\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModuleConfig","title":"<code>PickColumnModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> <p>Configuration for the 'table.cut_column' kiara module.</p> <p>Technically this is not necessary, because we could just use the 'constants' field to set the 'column_name'. But this module is used in the documentation as example, as it's easy enough to understand, and I wanted to show how implement kiara module configuration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class PickColumnModuleConfig(KiaraModuleConfig):\n\"\"\"Configuration for the 'table.cut_column' kiara module.\n\n    Technically this is not necessary, because we could just use the 'constants' field to\n    set the 'column_name'. But this module is used in the documentation as example, as it's easy enough to understand,\n    and I wanted to show how implement kiara module configuration.\n    \"\"\"\n\n    column_name: Union[str, None] = Field(\n        description=\"A hardcoded column name to cut.\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModuleConfig.column_name","title":"<code>column_name: Union[str, None] = Field(description='A hardcoded column name to cut.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule","title":"<code>PickColumnModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Pick one column from a table, returning an array.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class PickColumnModule(KiaraModule):\n\"\"\"Pick one column from a table, returning an array.\"\"\"\n\n    _module_type_name = \"table.pick.column\"\n    _config_cls = PickColumnModuleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        inputs: Dict[str, Any] = {\"table\": {\"type\": \"table\", \"doc\": \"A table.\"}}\n        column_name = self.get_config_value(\"column_name\")\n        if not column_name:\n            inputs[\"column_name\"] = {\n                \"type\": \"string\",\n                \"doc\": \"The name of the column to extract.\",\n            }\n\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        outputs: Mapping[str, Any] = {\"array\": {\"type\": \"array\", \"doc\": \"The column.\"}}\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        import pyarrow as pa\n\n        column_name: Union[str, None] = self.get_config_value(\"column_name\")\n        if not column_name:\n            column_name = inputs.get_value_data(\"column_name\")\n\n        if not column_name:\n            raise KiaraProcessingException(\n                \"Could not cut column from table: column_name not provided or empty string.\"\n            )\n\n        table_value: Value = inputs.get_value_obj(\"table\")\n        table_metadata: KiaraTableMetadata = table_value.get_property_data(\n            \"metadata.table\"\n        )\n        available = table_metadata.table.column_names\n\n        if column_name not in available:\n            raise KiaraProcessingException(\n                f\"Invalid column name '{column_name}'. Available column names: {', '.join(available)}\"\n            )\n\n        table: pa.Table = table_value.data.arrow_table\n        column = table.column(column_name)\n\n        outputs.set_value(\"array\", column)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule._config_cls","title":"<code>_config_cls = PickColumnModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    inputs: Dict[str, Any] = {\"table\": {\"type\": \"table\", \"doc\": \"A table.\"}}\n    column_name = self.get_config_value(\"column_name\")\n    if not column_name:\n        inputs[\"column_name\"] = {\n            \"type\": \"string\",\n            \"doc\": \"The name of the column to extract.\",\n        }\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    outputs: Mapping[str, Any] = {\"array\": {\"type\": \"array\", \"doc\": \"The column.\"}}\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.PickColumnModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    import pyarrow as pa\n\n    column_name: Union[str, None] = self.get_config_value(\"column_name\")\n    if not column_name:\n        column_name = inputs.get_value_data(\"column_name\")\n\n    if not column_name:\n        raise KiaraProcessingException(\n            \"Could not cut column from table: column_name not provided or empty string.\"\n        )\n\n    table_value: Value = inputs.get_value_obj(\"table\")\n    table_metadata: KiaraTableMetadata = table_value.get_property_data(\n        \"metadata.table\"\n    )\n    available = table_metadata.table.column_names\n\n    if column_name not in available:\n        raise KiaraProcessingException(\n            f\"Invalid column name '{column_name}'. Available column names: {', '.join(available)}\"\n        )\n\n    table: pa.Table = table_value.data.arrow_table\n    column = table.column(column_name)\n\n    outputs.set_value(\"array\", column)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableConfig","title":"<code>MergeTableConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class MergeTableConfig(KiaraModuleConfig):\n\n    inputs_schema: Dict[str, ValueSchema] = Field(\n        description=\"A dict describing the inputs for this merge process.\"\n    )\n    column_map: Dict[str, str] = Field(\n        description=\"A map describing\", default_factory=dict\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableConfig.inputs_schema","title":"<code>inputs_schema: Dict[str, ValueSchema] = Field(description='A dict describing the inputs for this merge process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableConfig.column_map","title":"<code>column_map: Dict[str, str] = Field(description='A map describing', default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule","title":"<code>MergeTableModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Create a table from other tables and/or arrays.</p> <p>This module needs configuration to be set (for now). It's currently not possible to merge an arbitrary number of tables/arrays, all tables to be merged must be specified in the module configuration.</p> <p>Column names of the resulting table can be controlled by the 'column_map' configuration, which takes the desired column name as key, and a field-name in the following format as value: - '[inputs_schema key]' for inputs of type 'array' - '[inputs_schema_key].orig_column_name' for inputs of type 'table'</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class MergeTableModule(KiaraModule):\n\"\"\"Create a table from other tables and/or arrays.\n\n    This module needs configuration to be set (for now). It's currently not possible to merge an arbitrary\n    number of tables/arrays, all tables to be merged must be specified in the module configuration.\n\n    Column names of the resulting table can be controlled by the 'column_map' configuration, which takes the\n    desired column name as key, and a field-name in the following format as value:\n    - '[inputs_schema key]' for inputs of type 'array'\n    - '[inputs_schema_key].orig_column_name' for inputs of type 'table'\n    \"\"\"\n\n    _module_type_name = \"table.merge\"\n    _config_cls = MergeTableConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        input_schema_dict = self.get_config_value(\"inputs_schema\")\n        return input_schema_dict\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        outputs = {\n            \"table\": {\n                \"type\": \"table\",\n                \"doc\": \"The merged table, including all source tables and columns.\",\n            }\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n        import pyarrow as pa\n\n        inputs_schema: Dict[str, Any] = self.get_config_value(\"inputs_schema\")\n        column_map: Dict[str, str] = self.get_config_value(\"column_map\")\n\n        sources = {}\n        for field_name in inputs_schema.keys():\n            sources[field_name] = inputs.get_value_data(field_name)\n\n        len_dict = {}\n        arrays = {}\n\n        column_map_final = dict(column_map)\n\n        for source_key, table_or_array in sources.items():\n\n            if isinstance(table_or_array, KiaraTable):\n                rows = table_or_array.num_rows\n                for name in table_or_array.column_names:\n                    array_name = f\"{source_key}.{name}\"\n                    if column_map and array_name not in column_map.values():\n                        job_log.add_log(\n                            f\"Ignoring column '{name}' of input table '{source_key}': not listed in column_map.\"\n                        )\n                        continue\n\n                    column = table_or_array.arrow_table.column(name)\n                    arrays[array_name] = column\n                    if not column_map:\n                        if name in column_map_final:\n                            raise Exception(\n                                f\"Can't merge table, duplicate column name: {name}.\"\n                            )\n                        column_map_final[name] = array_name\n\n            elif isinstance(table_or_array, KiaraArray):\n\n                if column_map and source_key not in column_map.values():\n                    job_log.add_log(\n                        f\"Ignoring array '{source_key}': not listed in column_map.\"\n                    )\n                    continue\n\n                rows = len(table_or_array)\n                arrays[source_key] = table_or_array.arrow_array\n\n                if not column_map:\n                    if source_key in column_map_final.keys():\n                        raise Exception(\n                            f\"Can't merge table, duplicate column name: {source_key}.\"\n                        )\n                    column_map_final[source_key] = source_key\n\n            else:\n                raise KiaraProcessingException(\n                    f\"Can't merge table: invalid type '{type(table_or_array)}' for source '{source_key}'.\"\n                )\n\n            len_dict[source_key] = rows\n\n        all_rows = None\n        for source_key, rows in len_dict.items():\n            if all_rows is None:\n                all_rows = rows\n            elif all_rows != rows:\n                all_rows = None\n                break\n\n        if all_rows is None:\n            len_str = \"\"\n            for name, rows in len_dict.items():\n                len_str = f\" {name} ({rows})\"\n\n            raise KiaraProcessingException(\n                f\"Can't merge table, sources have different lengths: {len_str}\"\n            )\n\n        column_names = []\n        columns = []\n        for column_name, ref in column_map_final.items():\n            column_names.append(column_name)\n            column = arrays[ref]\n            columns.append(column)\n\n        table = pa.Table.from_arrays(arrays=columns, names=column_names)\n\n        outputs.set_value(\"table\", table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule._config_cls","title":"<code>_config_cls = MergeTableConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    input_schema_dict = self.get_config_value(\"inputs_schema\")\n    return input_schema_dict\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    outputs = {\n        \"table\": {\n            \"type\": \"table\",\n            \"doc\": \"The merged table, including all source tables and columns.\",\n        }\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.MergeTableModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n    import pyarrow as pa\n\n    inputs_schema: Dict[str, Any] = self.get_config_value(\"inputs_schema\")\n    column_map: Dict[str, str] = self.get_config_value(\"column_map\")\n\n    sources = {}\n    for field_name in inputs_schema.keys():\n        sources[field_name] = inputs.get_value_data(field_name)\n\n    len_dict = {}\n    arrays = {}\n\n    column_map_final = dict(column_map)\n\n    for source_key, table_or_array in sources.items():\n\n        if isinstance(table_or_array, KiaraTable):\n            rows = table_or_array.num_rows\n            for name in table_or_array.column_names:\n                array_name = f\"{source_key}.{name}\"\n                if column_map and array_name not in column_map.values():\n                    job_log.add_log(\n                        f\"Ignoring column '{name}' of input table '{source_key}': not listed in column_map.\"\n                    )\n                    continue\n\n                column = table_or_array.arrow_table.column(name)\n                arrays[array_name] = column\n                if not column_map:\n                    if name in column_map_final:\n                        raise Exception(\n                            f\"Can't merge table, duplicate column name: {name}.\"\n                        )\n                    column_map_final[name] = array_name\n\n        elif isinstance(table_or_array, KiaraArray):\n\n            if column_map and source_key not in column_map.values():\n                job_log.add_log(\n                    f\"Ignoring array '{source_key}': not listed in column_map.\"\n                )\n                continue\n\n            rows = len(table_or_array)\n            arrays[source_key] = table_or_array.arrow_array\n\n            if not column_map:\n                if source_key in column_map_final.keys():\n                    raise Exception(\n                        f\"Can't merge table, duplicate column name: {source_key}.\"\n                    )\n                column_map_final[source_key] = source_key\n\n        else:\n            raise KiaraProcessingException(\n                f\"Can't merge table: invalid type '{type(table_or_array)}' for source '{source_key}'.\"\n            )\n\n        len_dict[source_key] = rows\n\n    all_rows = None\n    for source_key, rows in len_dict.items():\n        if all_rows is None:\n            all_rows = rows\n        elif all_rows != rows:\n            all_rows = None\n            break\n\n    if all_rows is None:\n        len_str = \"\"\n        for name, rows in len_dict.items():\n            len_str = f\" {name} ({rows})\"\n\n        raise KiaraProcessingException(\n            f\"Can't merge table, sources have different lengths: {len_str}\"\n        )\n\n    column_names = []\n    columns = []\n    for column_name, ref in column_map_final.items():\n        column_names.append(column_name)\n        column = arrays[ref]\n        columns.append(column)\n\n    table = pa.Table.from_arrays(arrays=columns, names=column_names)\n\n    outputs.set_value(\"table\", table)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQLModuleConfig","title":"<code>QueryTableSQLModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class QueryTableSQLModuleConfig(KiaraModuleConfig):\n\n    query: Union[str, None] = Field(\n        description=\"The query to execute. If not specified, the user will be able to provide their own.\",\n        default=None,\n    )\n    relation_name: Union[str, None] = Field(\n        description=\"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\",\n        default=\"data\",\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQLModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQLModuleConfig.query","title":"<code>query: Union[str, None] = Field(description='The query to execute. If not specified, the user will be able to provide their own.', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQLModuleConfig.relation_name","title":"<code>relation_name: Union[str, None] = Field(description='The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.', default='data')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL","title":"<code>QueryTableSQL</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Execute a sql query against an (Arrow) table.</p> <p>The default relation name for the sql query is 'data', but can be modified by the 'relation_name' config option/input.</p> <p>If the 'query' module config option is not set, users can provide their own query, otherwise the pre-set one will be used.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class QueryTableSQL(KiaraModule):\n\"\"\"Execute a sql query against an (Arrow) table.\n\n    The default relation name for the sql query is 'data', but can be modified by the 'relation_name' config option/input.\n\n    If the 'query' module config option is not set, users can provide their own query, otherwise the pre-set\n    one will be used.\n    \"\"\"\n\n    _module_type_name = \"query.table\"\n    _config_cls = QueryTableSQLModuleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        inputs = {\n            \"table\": {\n                \"type\": \"table\",\n                \"doc\": \"The table to query\",\n            }\n        }\n\n        if self.get_config_value(\"query\") is None:\n            inputs[\"query\"] = {\n                \"type\": \"string\",\n                \"doc\": \"The query, use the value of the 'relation_name' input as table, e.g. 'select * from data'.\",\n            }\n            inputs[\"relation_name\"] = {\n                \"type\": \"string\",\n                \"doc\": \"The name the table is referred to in the sql query.\",\n                \"default\": \"data\",\n            }\n\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\"query_result\": {\"type\": \"table\", \"doc\": \"The query result.\"}}\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        import duckdb\n\n        if self.get_config_value(\"query\") is None:\n            _query: str = inputs.get_value_data(\"query\")\n            _relation_name: str = inputs.get_value_data(\"relation_name\")\n        else:\n            _query = self.get_config_value(\"query\")\n            _relation_name = self.get_config_value(\"relation_name\")\n\n        if _relation_name.upper() in RESERVED_SQL_KEYWORDS:\n            raise KiaraProcessingException(\n                f\"Invalid relation name '{_relation_name}': this is a reserved sql keyword, please select a different name.\"\n            )\n\n        _table: KiaraTable = inputs.get_value_data(\"table\")\n        rel_from_arrow = duckdb.arrow(_table.arrow_table)\n        result: duckdb.DuckDBPyRelation = rel_from_arrow.query(_relation_name, _query)\n\n        outputs.set_value(\"query_result\", result.arrow())\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL._config_cls","title":"<code>_config_cls = QueryTableSQLModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    inputs = {\n        \"table\": {\n            \"type\": \"table\",\n            \"doc\": \"The table to query\",\n        }\n    }\n\n    if self.get_config_value(\"query\") is None:\n        inputs[\"query\"] = {\n            \"type\": \"string\",\n            \"doc\": \"The query, use the value of the 'relation_name' input as table, e.g. 'select * from data'.\",\n        }\n        inputs[\"relation_name\"] = {\n            \"type\": \"string\",\n            \"doc\": \"The name the table is referred to in the sql query.\",\n            \"default\": \"data\",\n        }\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\"query_result\": {\"type\": \"table\", \"doc\": \"The query result.\"}}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.QueryTableSQL.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    import duckdb\n\n    if self.get_config_value(\"query\") is None:\n        _query: str = inputs.get_value_data(\"query\")\n        _relation_name: str = inputs.get_value_data(\"relation_name\")\n    else:\n        _query = self.get_config_value(\"query\")\n        _relation_name = self.get_config_value(\"relation_name\")\n\n    if _relation_name.upper() in RESERVED_SQL_KEYWORDS:\n        raise KiaraProcessingException(\n            f\"Invalid relation name '{_relation_name}': this is a reserved sql keyword, please select a different name.\"\n        )\n\n    _table: KiaraTable = inputs.get_value_data(\"table\")\n    rel_from_arrow = duckdb.arrow(_table.arrow_table)\n    result: duckdb.DuckDBPyRelation = rel_from_arrow.query(_relation_name, _query)\n\n    outputs.set_value(\"query_result\", result.arrow())\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.ExportTableModule","title":"<code>ExportTableModule</code>","text":"<p>         Bases: <code>DataExportModule</code></p> <p>Export table data items.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class ExportTableModule(DataExportModule):\n\"\"\"Export table data items.\"\"\"\n\n    _module_type_name = \"export.table\"\n\n    def export__table__as__csv_file(self, value: KiaraTable, base_path: str, name: str):\n\"\"\"Export a table as csv file.\"\"\"\n\n        from pyarrow import csv\n\n        target_path = os.path.join(base_path, f\"{name}.csv\")\n        csv.write_csv(value.arrow_table, target_path)\n\n        return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.ExportTableModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.ExportTableModule.export__table__as__csv_file","title":"<code>export__table__as__csv_file(value: KiaraTable, base_path: str, name: str)</code>","text":"<p>Export a table as csv file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def export__table__as__csv_file(self, value: KiaraTable, base_path: str, name: str):\n\"\"\"Export a table as csv file.\"\"\"\n\n    from pyarrow import csv\n\n    target_path = os.path.join(base_path, f\"{name}.csv\")\n    csv.write_csv(value.arrow_table, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModuleBase","title":"<code>RenderTableModuleBase</code>","text":"<p>         Bases: <code>RenderValueModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class RenderTableModuleBase(RenderValueModule):\n\n    _module_type_name: str = None  # type: ignore\n\n    def preprocess_table(\n        self, value: Value, input_number_of_rows: int, input_row_offset: int\n    ):\n\n        import duckdb\n        import pyarrow as pa\n\n        if value.data_type_name == \"array\":\n            array: KiaraArray = value.data\n            arrow_table = pa.table(data=[array.arrow_array], names=[\"array\"])\n            column_names: Iterable[str] = [\"array\"]\n        else:\n            table: KiaraTable = value.data\n            arrow_table = table.arrow_table\n            column_names = table.column_names\n\n        columnns = [f'\"{x}\"' if not x.startswith('\"') else x for x in column_names]\n\n        query = f\"\"\"SELECT {', '.join(columnns)} FROM data LIMIT {input_number_of_rows} OFFSET {input_row_offset}\"\"\"\n\n        rel_from_arrow = duckdb.arrow(arrow_table)\n        query_result: duckdb.DuckDBPyRelation = rel_from_arrow.query(\"data\", query)\n\n        result_table = query_result.arrow()\n        wrap = ArrowTabularWrap(table=result_table)\n\n        related_scenes: Dict[str, Union[None, RenderScene]] = {}\n\n        row_offset = arrow_table.num_rows - input_number_of_rows\n\n        if row_offset &gt; 0:\n\n            if input_row_offset &gt; 0:\n                related_scenes[\"first\"] = RenderScene.construct(\n                    title=\"first\",\n                    description=f\"Display the first {input_number_of_rows} rows of this table.\",\n                    manifest_hash=self.manifest.manifest_hash,\n                    render_config={\n                        \"row_offset\": 0,\n                        \"number_of_rows\": input_number_of_rows,\n                    },\n                )\n\n                p_offset = input_row_offset - input_number_of_rows\n                if p_offset &lt; 0:\n                    p_offset = 0\n                previous = {\n                    \"row_offset\": p_offset,\n                    \"number_of_rows\": input_number_of_rows,\n                }\n                related_scenes[\"previous\"] = RenderScene.construct(title=\"previous\", description=f\"Display the previous {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=previous)  # type: ignore\n            else:\n                related_scenes[\"first\"] = None\n                related_scenes[\"previous\"] = None\n\n            n_offset = input_row_offset + input_number_of_rows\n            if n_offset &lt; arrow_table.num_rows:\n                next = {\"row_offset\": n_offset, \"number_of_rows\": input_number_of_rows}\n                related_scenes[\"next\"] = RenderScene.construct(title=\"next\", description=f\"Display the next {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=next)  # type: ignore\n            else:\n                related_scenes[\"next\"] = None\n\n            last_page = int(arrow_table.num_rows / input_number_of_rows)\n            current_start = last_page * input_number_of_rows\n            if (input_row_offset + input_number_of_rows) &gt; arrow_table.num_rows:\n                related_scenes[\"last\"] = None\n            else:\n                related_scenes[\"last\"] = RenderScene.construct(\n                    title=\"last\",\n                    description=\"Display the final rows of this table.\",\n                    manifest_hash=self.manifest.manifest_hash,\n                    render_config={\n                        \"row_offset\": current_start,  # type: ignore\n                        \"number_of_rows\": input_number_of_rows,  # type: ignore\n                    },\n                )\n        else:\n            related_scenes[\"first\"] = None\n            related_scenes[\"previous\"] = None\n            related_scenes[\"next\"] = None\n            related_scenes[\"last\"] = None\n\n        return wrap, related_scenes\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModuleBase-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModuleBase.preprocess_table","title":"<code>preprocess_table(value: Value, input_number_of_rows: int, input_row_offset: int)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def preprocess_table(\n    self, value: Value, input_number_of_rows: int, input_row_offset: int\n):\n\n    import duckdb\n    import pyarrow as pa\n\n    if value.data_type_name == \"array\":\n        array: KiaraArray = value.data\n        arrow_table = pa.table(data=[array.arrow_array], names=[\"array\"])\n        column_names: Iterable[str] = [\"array\"]\n    else:\n        table: KiaraTable = value.data\n        arrow_table = table.arrow_table\n        column_names = table.column_names\n\n    columnns = [f'\"{x}\"' if not x.startswith('\"') else x for x in column_names]\n\n    query = f\"\"\"SELECT {', '.join(columnns)} FROM data LIMIT {input_number_of_rows} OFFSET {input_row_offset}\"\"\"\n\n    rel_from_arrow = duckdb.arrow(arrow_table)\n    query_result: duckdb.DuckDBPyRelation = rel_from_arrow.query(\"data\", query)\n\n    result_table = query_result.arrow()\n    wrap = ArrowTabularWrap(table=result_table)\n\n    related_scenes: Dict[str, Union[None, RenderScene]] = {}\n\n    row_offset = arrow_table.num_rows - input_number_of_rows\n\n    if row_offset &gt; 0:\n\n        if input_row_offset &gt; 0:\n            related_scenes[\"first\"] = RenderScene.construct(\n                title=\"first\",\n                description=f\"Display the first {input_number_of_rows} rows of this table.\",\n                manifest_hash=self.manifest.manifest_hash,\n                render_config={\n                    \"row_offset\": 0,\n                    \"number_of_rows\": input_number_of_rows,\n                },\n            )\n\n            p_offset = input_row_offset - input_number_of_rows\n            if p_offset &lt; 0:\n                p_offset = 0\n            previous = {\n                \"row_offset\": p_offset,\n                \"number_of_rows\": input_number_of_rows,\n            }\n            related_scenes[\"previous\"] = RenderScene.construct(title=\"previous\", description=f\"Display the previous {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=previous)  # type: ignore\n        else:\n            related_scenes[\"first\"] = None\n            related_scenes[\"previous\"] = None\n\n        n_offset = input_row_offset + input_number_of_rows\n        if n_offset &lt; arrow_table.num_rows:\n            next = {\"row_offset\": n_offset, \"number_of_rows\": input_number_of_rows}\n            related_scenes[\"next\"] = RenderScene.construct(title=\"next\", description=f\"Display the next {input_number_of_rows} rows of this table.\", manifest_hash=self.manifest.manifest_hash, render_config=next)  # type: ignore\n        else:\n            related_scenes[\"next\"] = None\n\n        last_page = int(arrow_table.num_rows / input_number_of_rows)\n        current_start = last_page * input_number_of_rows\n        if (input_row_offset + input_number_of_rows) &gt; arrow_table.num_rows:\n            related_scenes[\"last\"] = None\n        else:\n            related_scenes[\"last\"] = RenderScene.construct(\n                title=\"last\",\n                description=\"Display the final rows of this table.\",\n                manifest_hash=self.manifest.manifest_hash,\n                render_config={\n                    \"row_offset\": current_start,  # type: ignore\n                    \"number_of_rows\": input_number_of_rows,  # type: ignore\n                },\n            )\n    else:\n        related_scenes[\"first\"] = None\n        related_scenes[\"previous\"] = None\n        related_scenes[\"next\"] = None\n        related_scenes[\"last\"] = None\n\n    return wrap, related_scenes\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModule","title":"<code>RenderTableModule</code>","text":"<p>         Bases: <code>RenderTableModuleBase</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>class RenderTableModule(RenderTableModuleBase):\n    _module_type_name = \"render.table\"\n\n    def render__table__as__string(self, value: Value, render_config: Mapping[str, Any]):\n\n        input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n        input_row_offset = render_config.get(\"row_offset\", 0)\n\n        wrap, data_related_scenes = self.preprocess_table(\n            value=value,\n            input_number_of_rows=input_number_of_rows,\n            input_row_offset=input_row_offset,\n        )\n        pretty = wrap.as_string(max_row_height=1)\n\n        return RenderValueResult(\n            value_id=value.value_id,\n            render_config=render_config,\n            render_manifest=self.manifest.manifest_hash,\n            rendered=pretty,\n            related_scenes=data_related_scenes,\n        )\n\n    def render__table__as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ):\n\n        input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n        input_row_offset = render_config.get(\"row_offset\", 0)\n\n        wrap, data_related_scenes = self.preprocess_table(\n            value=value,\n            input_number_of_rows=input_number_of_rows,\n            input_row_offset=input_row_offset,\n        )\n        pretty = wrap.as_terminal_renderable(max_row_height=1)\n\n        return RenderValueResult(\n            value_id=value.value_id,\n            render_config=render_config,\n            render_manifest=self.manifest.manifest_hash,\n            rendered=pretty,\n            related_scenes=data_related_scenes,\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModule.render__table__as__string","title":"<code>render__table__as__string(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def render__table__as__string(self, value: Value, render_config: Mapping[str, Any]):\n\n    input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n    input_row_offset = render_config.get(\"row_offset\", 0)\n\n    wrap, data_related_scenes = self.preprocess_table(\n        value=value,\n        input_number_of_rows=input_number_of_rows,\n        input_row_offset=input_row_offset,\n    )\n    pretty = wrap.as_string(max_row_height=1)\n\n    return RenderValueResult(\n        value_id=value.value_id,\n        render_config=render_config,\n        render_manifest=self.manifest.manifest_hash,\n        rendered=pretty,\n        related_scenes=data_related_scenes,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/__init__/#kiara_plugin.tabular.modules.table.RenderTableModule.render__table__as__terminal_renderable","title":"<code>render__table__as__terminal_renderable(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/__init__.py</code> <pre><code>def render__table__as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n):\n\n    input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n    input_row_offset = render_config.get(\"row_offset\", 0)\n\n    wrap, data_related_scenes = self.preprocess_table(\n        value=value,\n        input_number_of_rows=input_number_of_rows,\n        input_row_offset=input_row_offset,\n    )\n    pretty = wrap.as_terminal_renderable(max_row_height=1)\n\n    return RenderValueResult(\n        value_id=value.value_id,\n        render_config=render_config,\n        render_manifest=self.manifest.manifest_hash,\n        rendered=pretty,\n        related_scenes=data_related_scenes,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/","title":"filters","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule","title":"<code>TableFiltersModule</code>","text":"<p>         Bases: <code>FilterModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>class TableFiltersModule(FilterModule):\n\n    _module_type_name = \"table.filters\"\n\n    @classmethod\n    def retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n\n        return \"table\"\n\n    def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n\n        if filter_name in [\"select_columns\", \"drop_columns\"]:\n\n            return {\n                \"columns\": {\n                    \"type\": \"list\",\n                    \"doc\": \"The name of the columns to include.\",\n                    \"optional\": True,\n                },\n                \"ignore_invalid_column_names\": {\n                    \"type\": \"boolean\",\n                    \"doc\": \"Whether to ignore invalid column names.\",\n                    \"default\": True,\n                },\n            }\n        elif filter_name == \"select_rows\":\n            return {\n                \"match\": {\n                    \"type\": \"string\",\n                    \"doc\": \"The string token to match.\",\n                    \"optional\": True,\n                },\n                \"case_insensitive\": {\n                    \"type\": \"boolean\",\n                    \"doc\": \"Whether to ignore case.\",\n                    \"default\": True,\n                },\n            }\n\n        return None\n\n    def filter__select_columns(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n        import pyarrow as pa\n\n        ignore_invalid = filter_inputs[\"ignore_invalid_column_names\"]\n        column_names = filter_inputs[\"columns\"]\n\n        if not column_names:\n            return value\n\n        table: KiaraTable = value.data\n        arrow_table = table.arrow_table\n        _column_names = []\n        _columns = []\n\n        for column_name in column_names:\n            if column_name not in arrow_table.column_names:\n                if ignore_invalid:\n                    continue\n                else:\n                    raise KiaraProcessingException(\n                        f\"Can't select column '{column_name}' from table: column name not available. Available columns: {', '.join(arrow_table.column_names)}.\"\n                    )\n\n            column = arrow_table.column(column_name)\n            _column_names.append(column_name)\n            _columns.append(column)\n\n        return pa.table(data=_columns, names=_column_names)\n\n    def filter__drop_columns(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n        import pyarrow as pa\n\n        ignore_invalid = filter_inputs[\"ignore_invalid_column_names\"]\n        column_names_to_ignore = filter_inputs[\"columns\"]\n\n        if not column_names_to_ignore:\n            return value\n\n        table: KiaraTable = value.data\n        arrow_table = table.arrow_table\n\n        for column_name in column_names_to_ignore:\n            if column_name not in arrow_table.column_names:\n                if ignore_invalid:\n                    continue\n                else:\n                    raise KiaraProcessingException(\n                        f\"Can't select column '{column_name}' from table: column name not available. Available columns: {', '.join(arrow_table.column_names)}.\"\n                    )\n\n        _column_names = []\n        _columns = []\n        for column_name in arrow_table.column_names:\n\n            if column_name in column_names_to_ignore:\n                continue\n\n            column = arrow_table.column(column_name)\n            _column_names.append(column_name)\n            _columns.append(column)\n\n        return pa.table(data=_columns, names=_column_names)\n\n    def filter__select_rows(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n        match = filter_inputs.get(\"match\", None)\n        if not match:\n            return value\n\n        case_insensitive = filter_inputs.get(\"case_insensitive\", True)\n\n        import duckdb\n\n        _table: KiaraTable = value.data\n        rel_from_arrow = duckdb.arrow(_table.arrow_table)\n\n        if case_insensitive:\n            # query_tokens = [f\"LOWER({c}) GLOB LOWER('{match}')\" for c in rel_from_arrow.columns]\n            query_tokens = [\n                f\"regexp_matches(LOWER({c}), LOWER('{match}'))\"\n                for c in rel_from_arrow.columns\n            ]\n        else:\n            query_tokens = [\n                f\"regexp_matches({c}, '{match}')\" for c in rel_from_arrow.columns\n            ]\n        query = \" OR \".join(query_tokens)\n\n        result = rel_from_arrow.filter(query)\n        return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule.retrieve_supported_type","title":"<code>retrieve_supported_type() -&gt; Union[Dict[str, Any], str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>@classmethod\ndef retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n\n    return \"table\"\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule.create_filter_inputs","title":"<code>create_filter_inputs(filter_name: str) -&gt; Union[None, ValueMapSchema]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n\n    if filter_name in [\"select_columns\", \"drop_columns\"]:\n\n        return {\n            \"columns\": {\n                \"type\": \"list\",\n                \"doc\": \"The name of the columns to include.\",\n                \"optional\": True,\n            },\n            \"ignore_invalid_column_names\": {\n                \"type\": \"boolean\",\n                \"doc\": \"Whether to ignore invalid column names.\",\n                \"default\": True,\n            },\n        }\n    elif filter_name == \"select_rows\":\n        return {\n            \"match\": {\n                \"type\": \"string\",\n                \"doc\": \"The string token to match.\",\n                \"optional\": True,\n            },\n            \"case_insensitive\": {\n                \"type\": \"boolean\",\n                \"doc\": \"Whether to ignore case.\",\n                \"default\": True,\n            },\n        }\n\n    return None\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule.filter__select_columns","title":"<code>filter__select_columns(value: Value, filter_inputs: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>def filter__select_columns(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n    import pyarrow as pa\n\n    ignore_invalid = filter_inputs[\"ignore_invalid_column_names\"]\n    column_names = filter_inputs[\"columns\"]\n\n    if not column_names:\n        return value\n\n    table: KiaraTable = value.data\n    arrow_table = table.arrow_table\n    _column_names = []\n    _columns = []\n\n    for column_name in column_names:\n        if column_name not in arrow_table.column_names:\n            if ignore_invalid:\n                continue\n            else:\n                raise KiaraProcessingException(\n                    f\"Can't select column '{column_name}' from table: column name not available. Available columns: {', '.join(arrow_table.column_names)}.\"\n                )\n\n        column = arrow_table.column(column_name)\n        _column_names.append(column_name)\n        _columns.append(column)\n\n    return pa.table(data=_columns, names=_column_names)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule.filter__drop_columns","title":"<code>filter__drop_columns(value: Value, filter_inputs: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>def filter__drop_columns(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n    import pyarrow as pa\n\n    ignore_invalid = filter_inputs[\"ignore_invalid_column_names\"]\n    column_names_to_ignore = filter_inputs[\"columns\"]\n\n    if not column_names_to_ignore:\n        return value\n\n    table: KiaraTable = value.data\n    arrow_table = table.arrow_table\n\n    for column_name in column_names_to_ignore:\n        if column_name not in arrow_table.column_names:\n            if ignore_invalid:\n                continue\n            else:\n                raise KiaraProcessingException(\n                    f\"Can't select column '{column_name}' from table: column name not available. Available columns: {', '.join(arrow_table.column_names)}.\"\n                )\n\n    _column_names = []\n    _columns = []\n    for column_name in arrow_table.column_names:\n\n        if column_name in column_names_to_ignore:\n            continue\n\n        column = arrow_table.column(column_name)\n        _column_names.append(column_name)\n        _columns.append(column)\n\n    return pa.table(data=_columns, names=_column_names)\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/modules/table/filters/#kiara_plugin.tabular.modules.table.filters.TableFiltersModule.filter__select_rows","title":"<code>filter__select_rows(value: Value, filter_inputs: Mapping[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/tabular/modules/table/filters.py</code> <pre><code>def filter__select_rows(self, value: Value, filter_inputs: Mapping[str, Any]):\n\n    match = filter_inputs.get(\"match\", None)\n    if not match:\n        return value\n\n    case_insensitive = filter_inputs.get(\"case_insensitive\", True)\n\n    import duckdb\n\n    _table: KiaraTable = value.data\n    rel_from_arrow = duckdb.arrow(_table.arrow_table)\n\n    if case_insensitive:\n        # query_tokens = [f\"LOWER({c}) GLOB LOWER('{match}')\" for c in rel_from_arrow.columns]\n        query_tokens = [\n            f\"regexp_matches(LOWER({c}), LOWER('{match}'))\"\n            for c in rel_from_arrow.columns\n        ]\n    else:\n        query_tokens = [\n            f\"regexp_matches({c}, '{match}')\" for c in rel_from_arrow.columns\n        ]\n    query = \" OR \".join(query_tokens)\n\n    result = rel_from_arrow.filter(query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/tabular/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"}]}